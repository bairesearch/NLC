/*******************************************************************************
 *
 * This file is part of BAIPROJECT.
 *
 * BAIPROJECT is licensed under the GNU Affero General Public License
 * version 3, as published by the Free Software Foundation. The use of
 * intermediary programs or interfaces including file i/o is considered
 * remote network interaction. This does not imply such arrangements
 * do not constitute derivative works.
 *
 * BAIPROJECT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Affero General Public License
 * version 3 along with BAIPROJECT.  If not, see <http://www.gnu.org/licenses/>
 * for a copy of the AGPLv3 License.
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: NLClibraryStandardFileIO.hpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2016 Baxter AI (baxterai.com)
 * Project: Natural Language Compiler (Programming Interface)
 * Project Version: 2a4a 27-April-2017
 * Requirements: requires C++ code to be generated by NLC
 *
 *******************************************************************************/
 
#include "NLClibraryStandardFileIO.hpp"
#include "NLClibraryStandardOperations.hpp"
#include "NLCgenerated.hpp"
#include "SHAREDvars.hpp"	//required for convertStringToDouble
//#ifdef NLC_DEBUG_LIBRARY
#include "NLClibraryStandardPrint.hpp"
//#endif

//need to update to support .csv file io (not just xml file io)

//writeFunction() limitation: only supports NLC_ADVANCED_REFERENCING (not GIA_ADVANCED_REFERENCING)
void writeFunction(vector<NLCgenericEntityClass*>& writeClassList, vector<NLCgenericEntityClass*>& writeObjectClassList)
{
	bool result = true;
	
	for(vector<NLCgenericEntityClass*>::iterator iter1 = writeClassList.begin(); iter1 < writeClassList.end(); iter1++) 
	{
		NLCgenericEntityClass* writeAction = *iter1;
		unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* NLCgenericEntityToConditionList = getConditionListByConditionName(writeAction, NLC_LIBRARY_FILEIO_FUNCTION_ACTION_CONDITION_TO_NAME); 

		if(NLCgenericEntityToConditionList != NULL)
		{
			for(unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>::iterator iter2 = NLCgenericEntityToConditionList->begin(); iter2 != NLCgenericEntityToConditionList->end(); iter2++)
			{
				NLCgenericEntityClass* toConditionObject = iter2->second;
				if(toConditionObject->name == NLC_LIBRARY_FILEIO_FUNCTION_ACTIONOBJECT_FILE_NAME)
				{
					#ifdef NLC_DEBUG_LIBRARY
					cout << "writeFunction() pass" << endl;
					#endif
					int fileType = NLC_LIBRARY_FILEIO_FILETYPE_DEFAULT;
					string delimiter = NLC_LIBRARY_FILEIO_FLAT_DELIMITER_DEFAULT;
					string fileName = "";
					if(!(toConditionObject->aliasList.empty()))
					{
						fileName = toConditionObject->aliasList.back();	//eg write the People to the file called People.xml
						if(fileName.find(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_APPEND_XML) != CPP_STRING_FIND_RESULT_FAIL_VALUE)
						{
							fileType = NLC_LIBRARY_FILEIO_FILETYPE_XML;
						}
						else if(fileName.find(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_APPEND_CSV) != CPP_STRING_FIND_RESULT_FAIL_VALUE)
						{
							fileType = NLC_LIBRARY_FILEIO_FILETYPE_FLAT;
							delimiter = NLC_LIBRARY_FILEIO_FLAT_DELIMITER_COMMA;
						}
						else if(fileName.find(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_APPEND_TXT) != CPP_STRING_FIND_RESULT_FAIL_VALUE)
						{
							fileType = NLC_LIBRARY_FILEIO_FILETYPE_FLAT;
							delimiter = NLC_LIBRARY_FILEIO_FLAT_DELIMITER_TAB;
						}
					}
					else
					{
						//cout << "no filename alias found" << endl;	
						if(!writeObjectClassList.empty())
						{
							fileName = string(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_PREPEND) + (writeObjectClassList.back())->name + string(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_APPEND_XML);	//eg write the People to the file (generate file name NLCfileIOPeople.xml)
							fileType = NLC_LIBRARY_FILEIO_FILETYPE_XML;
							
						}
						else
						{
							cout << "writeFunction() error: function called without file contents (writeObjectClassList) specified" << endl;
						}					
					}
					//cout << "fileName = " << fileName << endl;
					//cout << "delimiter = " << delimiter << endl;
					
					if(fileType == NLC_LIBRARY_FILEIO_FILETYPE_XML)
					{
						XMLparserTag* firstTagInXMLFile = new XMLparserTag();
						writeXMLfilePropertyListEntry(firstTagInXMLFile, &writeObjectClassList);
 						if(!XMLparserClassClass().writeXMLfile(fileName, firstTagInXMLFile))
 						{
							result = false;
						}
					}
					else if(fileType == NLC_LIBRARY_FILEIO_FILETYPE_FLAT)
					{//csv
						//write to flat file - property lists only
 						if(!writeNLCflatFilePropertyLists(fileName, &writeObjectClassList, delimiter))
 						{
							result = false;
						}
					}
				}
			}
		}
		else
		{
			cout << "writeFunction() error: write action 'to' condition not found" << endl;
		}
	}
}

//#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_PROPERTY_LISTS
void writeXMLfilePropertyListEntry(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* writeObjectClassList)
{
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS_ENTRY
	writeXMLfilePropertyListRecurse(firstTagInList, writeObjectClassList);
	#else
	XMLparserTag* currentTagInList = firstTagInList;
	for(vector<NLCgenericEntityClass*>::iterator iter1 = writeObjectClassList->begin(); iter1 < writeObjectClassList->end(); iter1++) 
	{
		NLCgenericEntityClass* writeObject = *iter1;
		#ifdef NLC_DEBUG_LIBRARY
		cout << "writeXMLfileObject(): writeObject->name = " << writeObject->name << endl;
		#endif

		currentTagInList = writeXMLfileObject(currentTagInList, writeObject);
	}	
	#endif
}

void writeXMLfilePropertyListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* writeObjectClassList)
{
	writeXMLfileVectorList(firstTagInList, writeObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_PROPERTY_LIST);
}
void writeXMLfileVectorList(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* writeObjectClassList, string listName)
{
	if(!(writeObjectClassList->empty()))
	{
		XMLparserTag* currentTagInList = createVectorListTagWithLowerLevel(firstTagInList, listName, writeObjectClassList);
		for(vector<NLCgenericEntityClass*>::iterator iter1 = writeObjectClassList->begin(); iter1 < writeObjectClassList->end(); iter1++) 
		{
			NLCgenericEntityClass* writeObject = *iter1;
			#ifdef NLC_DEBUG_LIBRARY
			cout << "writeXMLfileObject(): writeObject->name = " << writeObject->name << endl;
			#endif

			currentTagInList = writeXMLfileObject(currentTagInList, writeObject);
		}
	}
}
XMLparserTag* createVectorListTagWithLowerLevel(XMLparserTag* currentTagInList, string tagName, vector<NLCgenericEntityClass*>* vectorClassList)
{
	currentTagInList->name = tagName;
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInList->firstAttribute->name = NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_LISTNAME;
	currentTagInList->firstAttribute->value = (vectorClassList->back())->name;
	currentTagInList->firstAttribute->nextAttribute = new XMLparserAttribute();
	#endif
	currentTagInList->nextTag = new XMLparserTag();
	currentTagInList->firstLowerLevelTag = new XMLparserTag();
	currentTagInList = currentTagInList->firstLowerLevelTag;
	return currentTagInList;
}
//#endif

#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_CONDITION_LISTS
void writeXMLfileConditionListRecurse(XMLparserTag* firstTagInList, unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* writeObjectClassMapList)
{
	writeXMLfileMapList(firstTagInList, writeObjectClassMapList, NLC_LIBRARY_FILEIO_XML_TAGNAME_CONDITION_LIST);
}
void writeXMLfileMapList(XMLparserTag* firstTagInList, unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* writeObjectClassMapList, string listName)
{
	if(!(writeObjectClassMapList->empty()))
	{
		XMLparserTag* currentTagInList = createMapListTagWithLowerLevel(firstTagInList, listName, writeObjectClassMapList);
		for(unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>::iterator iter1 = writeObjectClassMapList->begin(); iter1 != writeObjectClassMapList->end(); iter1++) 
		{
			NLCgenericEntityClass* writeObject = (iter1)->second;
			#ifdef NLC_NORMALISE_TWOWAY_PREPOSITIONS_MARK_INVERSE_CONDITIONS
			NLCgenericEntityClass* condition = (iter1)->first;
			if(!(condition->inverseConditionTwoWay))	//do not write inverse conditions
			{
			#endif
				#ifdef NLC_DEBUG_LIBRARY
				cout << "writeXMLfileObject(): writeObject->name = " << writeObject->name << endl;
				#endif

				currentTagInList->firstAttribute->name = NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_CONDITION;
				currentTagInList->firstAttribute->value = (iter1)->first->name;		//write condition name
				currentTagInList->firstAttribute->nextAttribute = new XMLparserAttribute(); 
				currentTagInList = writeXMLfileObject(currentTagInList, writeObject);
			#ifdef NLC_NORMALISE_TWOWAY_PREPOSITIONS_MARK_INVERSE_CONDITIONS
			}
			#endif		
		}
	}
}
XMLparserTag* createMapListTagWithLowerLevel(XMLparserTag* currentTagInList, string tagName, unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* writeObjectClassMapList)
{
	currentTagInList->name = tagName;
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	XMLparserAttribute* currentAttribute = currentTagInList->firstAttribute;
	string mapListName1 = writeObjectClassMapList->begin()->first->name;
	string mapListName2 = writeObjectClassMapList->begin()->second->name;
	currentAttribute->name = NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_MAPLISTNAME1;
	currentAttribute->value = mapListName1;
	currentAttribute->nextAttribute = new XMLparserAttribute();
	currentAttribute = currentAttribute->nextAttribute;
	currentAttribute->name = NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_MAPLISTNAME2;
	currentAttribute->value = mapListName2;
	currentAttribute->nextAttribute = new XMLparserAttribute();
	#endif
	currentTagInList->nextTag = new XMLparserTag();
	currentTagInList->firstLowerLevelTag = new XMLparserTag();
	currentTagInList = currentTagInList->firstLowerLevelTag;
	return currentTagInList;
}
#endif

#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_ACTION_LISTS
void writeXMLfileActionListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* writeObjectClassList)
{
	writeXMLfileVectorList(firstTagInList, writeObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTION_LIST);
}
void writeXMLfileActionIncomingListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* writeObjectClassList)
{
	writeXMLfileVectorList(firstTagInList, writeObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONINCOMING_LIST);
}
void writeXMLfileActionSubjectListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* writeObjectClassList)
{
	writeXMLfileVectorList(firstTagInList, writeObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONSUBJECT_LIST);
}
void writeXMLfileActionObjectListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* writeObjectClassList)
{
	writeXMLfileVectorList(firstTagInList, writeObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONOBJECT_LIST);
}
#endif






XMLparserTag* writeXMLfileObject(XMLparserTag* firstTagInList, NLCgenericEntityClass* writeObject)
{
	XMLparserTag* currentTagInList = createListTagWithLowerLevel(firstTagInList, writeObject->name);
	
	XMLparserTag* currentTagInListL2 = currentTagInList;
	
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_PROPERTY_LISTS
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInListL2 = createListTagWithLowerLevel(currentTagInList, NLC_LIBRARY_FILEIO_XML_TAGNAME_PROPERTY_LIST_ALL);
	#endif
	for(unordered_map<string, vector<NLCgenericEntityClass*>*>::iterator iter2 = writeObject->propertyLists.begin(); iter2 != writeObject->propertyLists.end(); iter2++)
	{
		string propertyListKey = iter2->first;
		vector<NLCgenericEntityClass*>* propertyList = iter2->second;
		if(!(propertyList->empty()))
		{
			writeXMLfilePropertyListRecurse(currentTagInListL2, propertyList);
			currentTagInListL2 = currentTagInListL2->nextTag;
		}
	}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInList = currentTagInList->nextTag;
	#endif
	#endif
	
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_CONDITION_LISTS
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInListL2 = createListTagWithLowerLevel(currentTagInList, NLC_LIBRARY_FILEIO_XML_TAGNAME_CONDITION_LIST_ALL);
	#endif
	for(unordered_map<pair<string, string>*, unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>*>::iterator iter2 = writeObject->conditionLists.begin(); iter2 != writeObject->conditionLists.end(); iter2++)
	{
		pair<string, string>* conditionListKey = iter2->first;
		unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* conditionList = iter2->second;
		if(!(conditionList->empty()))
		{
			writeXMLfileConditionListRecurse(currentTagInListL2, conditionList);
			currentTagInListL2 = currentTagInListL2->nextTag;
		}
	}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInList = currentTagInList->nextTag;
	#endif
	#endif
	
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_ACTION_LISTS
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInListL2 = createListTagWithLowerLevel(currentTagInList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTION_LIST_ALL);
	#endif
	for(unordered_map<string, vector<NLCgenericEntityClass*>*>::iterator iter2 = writeObject->propertyLists.begin(); iter2 != writeObject->propertyLists.end(); iter2++)
	{
		string propertyListKey = iter2->first;
		vector<NLCgenericEntityClass*>* actionList = iter2->second;
		if(!(actionList->empty()))
		{
			writeXMLfileActionListRecurse(currentTagInListL2, actionList);
			currentTagInListL2 = currentTagInListL2->nextTag;
		}
	}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInList = currentTagInList->nextTag;
	#endif
	
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInListL2 = createListTagWithLowerLevel(currentTagInList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONINCOMING_LIST_ALL);
	#endif
	for(unordered_map<string, vector<NLCgenericEntityClass*>*>::iterator iter2 = writeObject->actionIncomingLists.begin(); iter2 != writeObject->actionIncomingLists.end(); iter2++)
	{
		string propertyListKey = iter2->first;
		vector<NLCgenericEntityClass*>* actionIncomingList = iter2->second;
		if(!(actionIncomingList->empty()))
		{
			writeXMLfileActionIncomingListRecurse(currentTagInListL2, propertyList);
			currentTagInListL2 = currentTagInListL2->nextTag;
		}
	}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInList = currentTagInList->nextTag;
	#endif
	
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInListL2 = createListTagWithLowerLevel(currentTagInList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONSUBJECT_LIST_ALL);
	#endif
	for(unordered_map<string, vector<NLCgenericEntityClass*>*>::iterator iter2 = writeObject->actionSubjectLists.begin(); iter2 != writeObject->actionSubjectLists.end(); iter2++)
	{
		string propertyListKey = iter2->first;
		vector<NLCgenericEntityClass*>* actionSubjectList = iter2->second;
		if(!(actionSubjectList->empty()))
		{
			writeXMLfileActionSubjectListRecurse(currentTagInListL2, actionSubjectList);
			currentTagInListL2 = currentTagInListL2->nextTag;
		}
	}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInList = currentTagInList->nextTag;
	#endif
	
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInListL2 = createListTagWithLowerLevel(currentTagInList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONOBJECT_LIST_ALL);
	#endif
	for(unordered_map<string, vector<NLCgenericEntityClass*>*>::iterator iter2 = writeObject->actionObjectLists.begin(); iter2 != writeObject->actionObjectLists.end(); iter2++)
	{
		string propertyListKey = iter2->first;
		vector<NLCgenericEntityClass*>* actionObjectList = iter2->second;
		if(!(actionObjectList->empty()))
		{
			writeXMLfileActionObjectListRecurse(currentTagInListL2, actionObjectList);
			currentTagInListL2 = currentTagInListL2->nextTag;
		}
	}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	currentTagInList = currentTagInList->nextTag;
	#endif
	#endif
	
	return firstTagInList->nextTag;
}

XMLparserTag* createListTagWithLowerLevel(XMLparserTag* currentTagInList, string tagName)
{
	currentTagInList->name = tagName;
	currentTagInList->nextTag = new XMLparserTag();
	currentTagInList->firstLowerLevelTag = new XMLparserTag();
	currentTagInList = currentTagInList->firstLowerLevelTag;
	return currentTagInList;
}


/*
//consider creating an alias "get"/"add"/"read" eg "get/add/read the people from People.xml"
void getFunction(vector<moveClass*> &getClassList, vector<NLCgenericEntityClass*> &getObjectClassList)
{
	readFunction(getClassList, getObjectClassList)	
}
void addFunction(vector<moveClass*> &addClassList, vector<NLCgenericEntityClass*> &addObjectClassList)
{
	readFunction(addClassList, addObjectClassList)	
}
*/
void readFunction(vector<NLCgenericEntityClass*>& readClassList, vector<NLCgenericEntityClass*>& readObjectClassList)	
{
	bool result = true;
	vector<NLCgenericEntityClass*>* toConditionReadObjectClassList = NULL;
	for(vector<NLCgenericEntityClass*>::iterator iter1 = readClassList.begin(); iter1 < readClassList.end(); iter1++) 
	{
		NLCgenericEntityClass* readAction = *iter1;
		
		//added 1q14i
		unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* NLCgenericEntityToConditionList = getConditionListByConditionName(readAction, NLC_LIBRARY_FILEIO_FUNCTION_ACTION_CONDITION_TO_NAME); 
		NLCgenericEntityClass* toConditionObject = NULL;
		if(NLCgenericEntityToConditionList != NULL)
		{
			for(unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>::iterator iter2 = NLCgenericEntityToConditionList->begin(); iter2 != NLCgenericEntityToConditionList->end(); iter2++)
			{
				toConditionObject = iter2->second;
			}
		}
		if(toConditionObject == NULL)
		{
			cout << "readFunction() error: read action 'to' condition not found. Current NLC limitation; The user cannot have an executed function (e.g. readFunction) fill a local list (e.g. the people local list in 'read the people from the file called x.xml'). The user must specify the object being modified, (e.g. 'read the people from the file called x.xml to the company')." << endl;
		}		
					
		unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* NLCgenericEntityFromConditionList = getConditionListByConditionName(readAction, NLC_LIBRARY_FILEIO_FUNCTION_ACTION_CONDITION_FROM_NAME); 
		if(NLCgenericEntityFromConditionList != NULL)
		{			
			for(unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>::iterator iter2 = NLCgenericEntityFromConditionList->begin(); iter2 != NLCgenericEntityFromConditionList->end(); iter2++)
			{
				NLCgenericEntityClass* fromConditionObject = iter2->second;				
				if(fromConditionObject->name == NLC_LIBRARY_FILEIO_FUNCTION_ACTIONOBJECT_FILE_NAME)
				{
					#ifdef NLC_DEBUG_LIBRARY
					cout << "readFunction() pass" << endl;
					#endif
					
					int fileType = NLC_LIBRARY_FILEIO_FILETYPE_DEFAULT;
					string delimiter = NLC_LIBRARY_FILEIO_FLAT_DELIMITER_DEFAULT;
					string fileName = "";
					if(!(fromConditionObject->aliasList.empty()))
					{
						fileName = fromConditionObject->aliasList.back();	//eg read the People from the file called People.xml
						if(fileName.find(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_APPEND_XML) != CPP_STRING_FIND_RESULT_FAIL_VALUE)
						{
							fileType = NLC_LIBRARY_FILEIO_FILETYPE_XML;
						}
						else if(fileName.find(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_APPEND_CSV) != CPP_STRING_FIND_RESULT_FAIL_VALUE)
						{
							fileType = NLC_LIBRARY_FILEIO_FILETYPE_FLAT;
						}
						else if(fileName.find(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_APPEND_TXT) != CPP_STRING_FIND_RESULT_FAIL_VALUE)
						{
							fileType = NLC_LIBRARY_FILEIO_FILETYPE_FLAT;
							delimiter = NLC_LIBRARY_FILEIO_FLAT_DELIMITER_TAB;
						}
					}
					else
					{
						if(!readObjectClassList.empty())
						{
							fileName = string(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_PREPEND) + (readObjectClassList.back())->name + string(NLC_LIBRARY_FILEIO_FUNCTION_DEFAULT_FILE_NAME_APPEND_XML);	//eg read the People from the file (NLCfileIOPeople.xml)
						}
						else
						{
							cout << "readFunction() error: function called without file contents (readObjectClassList) specified" << endl;
							//OLD: Read function must be called with either a) fileName alias specified (e.g. read the people from the file called NLCfileIOPeople.xml to the company) or b) readObjectClassList filled (e.g. read the people from a file called NLCfileIOPeople.xml to the company, or only if the file has previously been initialised in context; read the people from a file called NLCfileIOPeople.xml to the company) " << endl;
						}
					}
					//cout << "fileName = " << fileName << endl;
					
					if(fileType == NLC_LIBRARY_FILEIO_FILETYPE_XML)
					{
						XMLparserTag* firstTagInXMLFile = new XMLparserTag();
 						if(!XMLparserClassClass().readXMLfile(fileName, firstTagInXMLFile))
 						{
							result = false;
						}
						
						string parentObjectName = "";
						if(!readObjectClassList.empty())
						{
							parentObjectName = (readObjectClassList.back())->name;
							toConditionReadObjectClassList = getPropertyListByName(toConditionObject, parentObjectName);
						}
						else
						{
							//take the name of the toConditionReadObjectClassList from the xml file
							parentObjectName = getTopLevelPropertyListNameFromXMLreadFileContents(firstTagInXMLFile);
							toConditionReadObjectClassList = getPropertyListByName(toConditionObject, parentObjectName);
						}
						
						if(toConditionReadObjectClassList == NULL)
						{
							cout << "readFunction() error: !getPropertyListByName; toConditionObject = " << toConditionObject->name << ", parentObjectName = " << parentObjectName << endl;
							cout << "A propertyList is being read from the toConditionObject, but this list is not being used by the user natural language code (i.e. generated NLC class definitions do not include this list)." << endl; 
							result = false;
						}
						else
						{
							if(!readXMLfileToNLCpropertyListsEntry(firstTagInXMLFile, toConditionReadObjectClassList))
							{
								result = false;
							}
						}
					}
					else if(fileType == NLC_LIBRARY_FILEIO_FILETYPE_FLAT)
					{//csv
						if(!readObjectClassList.empty())
						{
							toConditionReadObjectClassList = getPropertyListByName(toConditionObject, (readObjectClassList.back())->name);
						}
						else
						{	
							cout << "readFunction() error: function called without file contents (readObjectClassList) specified: not supported for flat files." << endl;
							cout << "read function must be called with readObjectClassList filled (e.g. read a person from a file called NLCfileIOPeople.xml to the company, or only if one or more people has previously been initialised in context; read the people from a file called NLCfileIOPeople.xml to the company)" << endl;
							result = false;
						}
						
						if(toConditionReadObjectClassList == NULL)
						{
							cout << "readFunction() error: !getPropertyListByName; toConditionObject = " << toConditionObject->name << ", (readObjectClassList.back())->name = " << (readObjectClassList.back())->name << endl;
							cout << "A propertyList is being read from the toConditionObject, but this list is not being used by the user natural language code (i.e. generated NLC class definitions do not include this list)." << endl; 
							result = false;
						}
						else
						{
							string parentObjectName = (readObjectClassList.back())->name;
														
							//read from flat file - property lists only
 							if(!readNLCflatfilePropertyLists(fileName, toConditionReadObjectClassList, delimiter, parentObjectName))
 							{
								result = false;
							}
						}
					}
				}
			}
		}
		else
		{
			cout << "readFunction() error: read action 'from' condition not found" << endl;
		}
	}
		
	#ifdef NLC_DEBUG_LIBRARY
	printFunction(readClassList, *toConditionReadObjectClassList);
	#endif
}

string getTopLevelPropertyListNameFromXMLreadFileContents(XMLparserTag* firstTagInXMLFile)
{
	string topLevelPropertyListName = "";
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS_ENTRY
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	if(firstTagInXMLFile->firstAttribute != NULL)
	{
		if(firstTagInXMLFile->firstAttribute->name == NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_LISTNAME)
		{
			topLevelPropertyListName = firstTagInXMLFile->firstAttribute->value;
		}
		else
		{
			cout << "getTopLevelPropertyListNameFromXMLreadFileContents{} error: firstTagInXMLFile->firstAttribute->name != NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_LISTNAME" << endl;
		}
	}
	else
	{
		cout << "getTopLevelPropertyListNameFromXMLreadFileContents{} error: firstTagInXMLFile->firstAttribute == NULL" << endl;
	}		
	#else
	//go down one layer to extract file name
	if(firstTagInXMLFile->firstLowerLevelTag != NULL)
	{
		topLevelPropertyListName = firstTagInXMLFile->firstLowerLevelTag->name;
	}
	else
	{
		cout << "getTopLevelPropertyListNameFromXMLreadFileContents{} error: firstTagInXMLFile->firstLowerLevelTag == NULL" << endl;
	}
	#endif
	#else
	topLevelPropertyListName = firstTagInXMLFile->name;
	#endif
	//cout << "topLevelPropertyListName = " << topLevelPropertyListName << endl;
	return topLevelPropertyListName;
}

bool readXMLfileToNLCpropertyListsEntry(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList)
{
	bool result = true;
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS_ENTRY
	if(firstTagInList->name == NLC_LIBRARY_FILEIO_XML_TAGNAME_PROPERTY_LIST)	//redundant
	{
		if(!readXMLfilePropertyListRecurse(firstTagInList, readObjectClassList))
		{
			result = false;
		}
	}
	else
	{
		cout << "readXMLfile error: propertyList tag not detected";
		result = false;
	}
	#else
	XMLparserTag* currentTagInVectorList = firstTagInList;
	while(currentTagInVectorList->nextTag != NULL)
	{
		NLCgenericEntityClass* readObject = generateObjectByName(currentTagInVectorList->name);
		readObjectClassList->push_back(readObject);
		
		readXMLfileObject(currentTagInVectorList, readObject);
		currentTagInVectorList = currentTagInVectorList->nextTag;
	}	
	#endif
	return result;
}						

//#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_PROPERTY_LISTS
bool readXMLfilePropertyListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList)
{
	bool result = true;
	if(!readXMLfileVectorList(firstTagInList, readObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_PROPERTY_LIST))
	{
		result = false;
	}
	return result;
}
bool readXMLfileVectorList(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList, string listName)
{
	bool result = true;
	if(firstTagInList->name == listName)
	{
		XMLparserTag* currentTagInVectorList = firstTagInList->firstLowerLevelTag;
		while(currentTagInVectorList->nextTag != NULL)
		{
			NLCgenericEntityClass* readObject = generateObjectByName(currentTagInVectorList->name);	
			readObjectClassList->push_back(readObject);		

			readXMLfileObject(currentTagInVectorList, readObject);
			currentTagInVectorList = currentTagInVectorList->nextTag;
		}
	}
	else
	{
		cout << "readXMLfileVectorList error: " << listName << " tag not detected";
		result = false;
	}
}
//#endif

#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_CONDITION_LISTS
bool readXMLfileConditionListRecurse(XMLparserTag* firstTagInList, unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* readObjectClassMapList)
{
	return readXMLfileMapList(firstTagInList, readObjectClassMapList, NLC_LIBRARY_FILEIO_XML_TAGNAME_CONDITION_LIST);
}
bool readXMLfileMapList(XMLparserTag* firstTagInList, unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* readObjectClassMapList, string listName)
{
	bool result = true;
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	if(firstTagInList->name == listName)
	{
	#endif
		XMLparserTag* currentTagInVectorList = firstTagInList->firstLowerLevelTag;
		while(currentTagInVectorList->nextTag != NULL)
		{
			NLCgenericEntityClass* readObject = generateObjectByName(currentTagInVectorList->name);
			if(currentTagInVectorList->firstAttribute != NULL)
			{
				if(currentTagInVectorList->firstAttribute->name == NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_CONDITION)
				{
					NLCgenericEntityClass* readObjectCondition = generateObjectByName(currentTagInVectorList->firstAttribute->value);
					readObjectClassMapList->insert(pair<NLCgenericEntityClass*, NLCgenericEntityClass*>(readObjectCondition, readObject));	//CHECKTHIS: check can insert as NLCgenericEntityClass and not their specificObjectClassName
				}
				else
				{
					cout << "readXMLfileMapList error: firstAttributeInTag->name != 'condition'" << endl;
					result = false;	
				}
			}
			else
			{
				cout << "readXMLfileMapList error: firstAttributeInTag tag not detected";
				result = false;	
			}
			
			/*
			if(currentTagInVectorList->firstLowerLevelTag != NULL)
			{
				readXMLfileObject(currentTagInVectorList->firstLowerLevelTag, readObject);
			}
			*/
			readXMLfileObject(currentTagInVectorList, readObject);
			currentTagInVectorList = currentTagInVectorList->nextTag;
		}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	}
	else
	{
		cout << "readXMLfileMapList error: " << listName << " tag not detected";
		result = false;
	}
	#endif
	return result;
}
#endif

#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_ACTION_LISTS
void readXMLfileActionListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList)
{
	readXMLfileVectorList(firstTagInList, readObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTION_LIST);
}
void readXMLfileActionIncomingListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList)
{
	readXMLfileVectorList(firstTagInList, readObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONINCOMING_LIST);
}
void readXMLfileActionSubjectListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList)
{
	readXMLfileVectorList(firstTagInList, readObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONSUBJECT_LIST);
}
void readXMLfileActionObjectListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList)
{
	readXMLfileVectorList(firstTagInList, readObjectClassList, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONOBJECT_LIST);
}
#endif


void readXMLfileObject(XMLparserTag* firstTagInList, NLCgenericEntityClass* readObject)
{
	/*
	#ifndef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS	//yet to code this
	if(firstTagInList
	vector<NLCgenericEntityClass*>* propertyList = getPropertyListByName(readObject, propertyListName);
	readXMLfilePropertyListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList)
	
	void readXMLfilePropertyListRecurse(XMLparserTag* firstTagInList, vector<NLCgenericEntityClass*>* readObjectClassList)

	#else
	*/
	
	XMLparserTag* currentTagInList = firstTagInList->firstLowerLevelTag;
	while(currentTagInList->nextTag != NULL)
	{		
		#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_PROPERTY_LISTS
		readFileObjectVectorListAll(currentTagInList, readObject, NLC_LIBRARY_FILEIO_XML_TAGNAME_PROPERTY_LIST_ALL, NLC_LIBRARY_FILEIO_XML_TAGNAME_PROPERTY_LIST);
		#endif

		#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_CONDITION_LISTS
		readFileObjectMapListAll(currentTagInList, readObject, NLC_LIBRARY_FILEIO_XML_TAGNAME_CONDITION_LIST_ALL, NLC_LIBRARY_FILEIO_XML_TAGNAME_CONDITION_LIST);
		#endif

		#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_ACTION_LISTS
		readFileObjectVectorListAll(currentTagInList, readObject, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTION_LIST_ALL, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTION_LIST);
		readFileObjectVectorListAll(currentTagInList, readObject, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONINCOMING_LIST_ALL, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONINCOMING_LIST);
		readFileObjectVectorListAll(currentTagInList, readObject, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONSUBJECT_LIST_ALL, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONSUBJECT_LIST);
		readFileObjectVectorListAll(currentTagInList, readObject, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONOBJECT_LIST_ALL, NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONOBJECT_LIST);
		#endif
	
		currentTagInList = currentTagInList->nextTag;
	}
}


bool readFileObjectVectorListAll(XMLparserTag* currentTagInList, NLCgenericEntityClass* readObject, string vectorListAllTagName, string vectorListTagName)
{
	bool result = true;
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	if(currentTagInList->name == vectorListAllTagName)
	{
		XMLparserTag* currentTagInVectorListAll = currentTagInList->firstLowerLevelTag;
		while(currentTagInVectorListAll->nextTag != NULL)
		{
			if(currentTagInVectorListAll->name == vectorListTagName)
			{
				string vectorListName = "";
				if(currentTagInVectorListAll->firstAttribute->name == NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_LISTNAME)
				{
					vectorListName = currentTagInVectorListAll->firstAttribute->value;
				}
				else
				{
					cout << "readXMLfileObject error(): " << vectorListTagName << ": currentTagInVectorListAll->firstAttribute->name != NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_LISTNAME" << endl;
					cout << "currentTagInVectorListAll->firstAttribute->name = " << currentTagInVectorListAll->firstAttribute->name << endl;
					result = false;
				}	
	#else
	if(currentTagInList->name == vectorListTagName)
	{
		XMLparserTag* currentTagInVectorListAll = currentTagInList;
		string vectorListName = "";	
		if(currentTagInVectorListAll->firstLowerLevelTag != NULL)
		{
			vectorListName = currentTagInVectorListAll->firstLowerLevelTag->name;	//extract the name of the vectorList from the first object in the list										
		}
	#endif				
				vector<NLCgenericEntityClass*>* vectorList = NULL;
				if(vectorListTagName == NLC_LIBRARY_FILEIO_XML_TAGNAME_PROPERTY_LIST)
				{
					vectorList = getPropertyListByName(readObject, vectorListName);
				}
				else if(vectorListTagName == NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTION_LIST)
				{
					vectorList = getActionListByName(readObject, vectorListName);
				}
				else if(vectorListTagName == NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONINCOMING_LIST)
				{
					vectorList = getActionIncomingListByName(readObject, vectorListName);
				}
				else if(vectorListTagName == NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONOBJECT_LIST)
				{
					vectorList = getActionObjectListByName(readObject, vectorListName);
				}
				else if(vectorListTagName == NLC_LIBRARY_FILEIO_XML_TAGNAME_ACTIONSUBJECT_LIST)
				{
					vectorList = getActionSubjectListByName(readObject, vectorListName);

				}
				else
				{
					cout << "readFileObjectVectorListAll() error: illegal vectorListTagName" << endl;
				}
				
				if(vectorList == NULL)
				{
					cout << "readFileObjectVectorListAll() warning: !getXListByName; readObject = " << readObject->name << ", vectorListName = " << vectorListName << endl;
					cout << "A " << vectorListTagName << " is being read from file, but this list is not being used by the user natural language code (i.e. generated NLC class definitions do not include this list)." << endl; 
					cout << "This list (and its contents) will therefore be ignored by NLC." << endl; 
				}
				else
				{				
					readXMLfileVectorList(currentTagInVectorListAll, vectorList, vectorListTagName);
				}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
			}
			currentTagInVectorListAll = currentTagInVectorListAll->nextTag;	
		}
	}
	#else
	}
	#endif
	return result;
}

#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_CONDITION_LISTS
bool readFileObjectMapListAll(XMLparserTag* currentTagInList, NLCgenericEntityClass* readObject, string mapListAllTagName, string mapListTagName)
{
	bool result = true;
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
	if(currentTagInList->name == mapListAllTagName)
	{
		XMLparserTag* currentTagInMapListAll = currentTagInList->firstLowerLevelTag;
		while(currentTagInMapListAll->nextTag != NULL)
		{
			if(currentTagInMapListAll->name == mapListTagName)
			{
				string mapListName1 = "";
				if(currentTagInMapListAll->firstAttribute->name == NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_MAPLISTNAME1)
				{
					mapListName1 = currentTagInMapListAll->firstAttribute->value;
				}
				else
				{
					cout << "readFileObjectMapListAll error(): " << mapListTagName << ": currentTagInMapListAll->firstAttribute->name != NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_MAPLISTNAME1" << endl;
					result = false;
				}
				string mapListName2 = "";
				if(currentTagInMapListAll->firstAttribute->nextAttribute != NULL)
				{
					if(currentTagInMapListAll->firstAttribute->nextAttribute->name == NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_MAPLISTNAME2)
					{
						mapListName2 = currentTagInMapListAll->firstAttribute->nextAttribute->value;
					}
					else
					{
						cout << "readFileObjectMapListAll error(): " << mapListTagName << ": currentTagInMapListAll->firstAttribute->nextAttribute->name != NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_MAPLISTNAME2" << endl;
						result = false;
					}
				}	
				else
				{
					cout << "readFileObjectMapListAll error(): " << mapListTagName << ": currentTagInMapListAll->firstAttribute->nextAttribute == NULL" << endl;
					result = false;
				}
	#else
	if(currentTagInList->name == mapListTagName)
	{
		XMLparserTag* currentTagInMapListAll = currentTagInList;
		string mapListName1 = "";
		string mapListName2 = "";	
		if(currentTagInMapListAll->firstLowerLevelTag != NULL)
		{
			mapListName2 = currentTagInMapListAll->firstLowerLevelTag->name;	//extract the name of the vectorList from the first object in the list
			if(currentTagInMapListAll->firstLowerLevelTag->firstAttribute->name == NLC_LIBRARY_FILEIO_XML_ATTRIBUTENAME_CONDITION)
			{
				mapListName1 = currentTagInMapListAll->firstLowerLevelTag->firstAttribute->value;	//extract the name of the vectorList from the first object in the list (its attribute)
			}
			else
			{
				/*
				cout << "readFileObjectMapListAll{} error: conditionList entry (ie conditonObject) does not have a condition attribute assigned" << endl;
				cout << "currentTagInMapList->name = " << currentTagInMapListAll->name << endl;
				cout << "conditionObject name = " << mapListName2 << endl;
				cout << "empty conditionList detected (inverse condition detected)" << endl;
				*/
				result = false;
			}
		}
		if(result)
		{									
	#endif
				unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*>* mapList = NULL;
				if(mapListTagName == NLC_LIBRARY_FILEIO_XML_TAGNAME_CONDITION_LIST)
				{
					mapList = getConditionListByName(readObject, mapListName1, mapListName2);
				}
				
				if(mapList == NULL)
				{
					cout << "readFileObjectMapListAll() warning: !getConditionListByName; readObject = " << readObject->name << ", mapListName1 = " << mapListName1 << ", mapListName2 = " << mapListName2 <<endl;
					cout << "A " << mapListTagName << " is being read from file, but this list is not being used by the user natural language code (i.e. generated NLC class definitions do not include this list)." << endl; 
					cout << "This list (and its contents) will therefore be ignored by NLC." << endl; 
				}
				else
				{
					readXMLfileConditionListRecurse(currentTagInMapListAll, mapList);
				}
	#ifdef NLC_LIBRARY_FILEIO_XML_WRITE_LIST_TAGS
			}
			currentTagInMapListAll = currentTagInMapListAll->nextTag;		
		}
	}
	#else
		}
	}
	#endif
	return result;
}
#endif


//limitation; 3D lists not currently supported (ie childObjects cannot be plural lists)
bool writeNLCflatFilePropertyLists(string fileName, vector<NLCgenericEntityClass*>* writeObjectClassList, string delimiter)
{
	bool result = true;
	
	string fileContents = "";
	bool firstLineWriteHeader = true;
	bool lineIndex = 1;
	for(vector<NLCgenericEntityClass*>::iterator iter1 = writeObjectClassList->begin(); iter1 < writeObjectClassList->end(); iter1++) 
	{
		NLCgenericEntityClass* parentObject = *iter1;
		if(firstLineWriteHeader)
		{
			string fileHeader = "";
			bool firstRow = true;
			for(unordered_map<string, vector<NLCgenericEntityClass*>*>::iterator iter2 = parentObject->propertyLists.begin(); iter2 != parentObject->propertyLists.end(); iter2++) 
			{
				if(!firstRow)
				{
					fileHeader = fileHeader + delimiter;
				}
				string variableName = iter2->first;
				vector<NLCgenericEntityClass*>* childObjectList = iter2->second;
				if(!(childObjectList->empty()))
				{
					NLCgenericEntityClass* childObject = childObjectList->back();	//limitation; 3D lists not currently supported (ie childObjects cannot be plural lists)
				}
				fileHeader = fileHeader + variableName;		//childObject will be NULL if childObjectList is empty, so use variableName instead
				firstRow = false;
			}
			//cout << "fileHeader = " << fileHeader << endl;
			fileContents = fileContents + fileHeader + STRING_NEW_LINE;
			firstLineWriteHeader = false;
			lineIndex++;
		}
		bool firstRow = true;
		string fileLine = "";
		for(unordered_map<string, vector<NLCgenericEntityClass*>*>::iterator iter2 = parentObject->propertyLists.begin(); iter2 != parentObject->propertyLists.end(); iter2++) 
		{
			if(!firstRow)
			{
				fileLine = fileLine + delimiter;
			}
			string variableName = iter2->first;
			vector<NLCgenericEntityClass*>* childObjectList = iter2->second;
			if(!(childObjectList->empty()))
			{
				NLCgenericEntityClass* childObject = childObjectList->back();	//limitation; 3D lists not currently supported (ie childObjects cannot be plural lists)
				if(!(childObject->aliasList.empty()))
				{
					string value = childObject->aliasList.back();
					fileLine = fileLine + value;
				}
				else if(childObject->mathObjectType == NLC_MATH_OBJECTS_VARIABLE_TYPE_NUMERICAL)
				{
					string value = to_string(childObject->mathObjectNumericalValue);
					fileLine = fileLine + value;
				}
				#ifdef NLC_MATH_OBJECTS_ADVANCED
				#ifdef NLC_MATH_OBJECTS_STRING
				else if(childObject->mathObjectType == NLC_MATH_OBJECTS_VARIABLE_TYPE_STRING)
				{
					string value = childObject->mathObjectStringValue;
					fileLine = fileLine + value;
				}
				#endif
				#ifdef NLC_MATH_OBJECTS_BOOLEAN
				else if(childObject->mathObjectType == NLC_MATH_OBJECTS_VARIABLE_TYPE_BOOLEAN)
				{
					string value = to_string(int(childObject->mathObjectBooleanValue));
					fileLine = fileLine + value;
				}
				#endif
				#endif
				else
				{
					string value = NLC_LIBRARY_FILEIO_FLAT_PRESENT_PROPERTY_VALUE;
					fileLine = fileLine + value;
				}
			}
			else
			{
				fileLine = fileLine + NLC_LIBRARY_FILEIO_FLAT_NULL_PROPERTY_VALUE;
			}
			firstRow = false;
		}
		//cout << "fileLine = " << fileLine << endl;
		fileContents = fileContents + fileLine + STRING_NEW_LINE;
		lineIndex++;
	}
	//cout << "fileContents = " << fileContents << endl;
	
	SHAREDvarsClass().writeStringToFile(fileName, &fileContents);
	
	return result;
}

//readNLCflatfilePropertyLists() limitation: data cells containing both alpha and numeric (eg variable1) is not allowed; as anything containing numeric will currently be treated as numeric 
bool readNLCflatfilePropertyLists(string fileName, vector<NLCgenericEntityClass*>* readObjectClassList, string delimiter, string parentObjectName)
{
	bool result = true;
	
	ifstream parseFileObject(fileName.c_str());
	if(!parseFileObject.rdbuf()->is_open())
	{
		//file does not exist in current directory.
		cout << "readNLCflatfilePropertyLists() error: input file does not exist in current directory: " << fileName << endl;
		result = false;
	}
	else
	{
		int lineIndex = 1;
		string currentLine;
		if(getline(parseFileObject, currentLine))
		{	
			string delimiter = NLC_LIBRARY_FILEIO_FLAT_DELIMITER_DEFAULT;
			for(int i=0; i<NLC_LIBRARY_FILEIO_FLAT_NUMBER_OF_DELIMITERS; i++)
			{
				if(currentLine.find(nlcLibraryFileIOflatFileDelimiters[i]) != CPP_STRING_FIND_RESULT_FAIL_VALUE)
				{
					delimiter = nlcLibraryFileIOflatFileDelimiters[i];
					if(delimiter != NLC_LIBRARY_FILEIO_FLAT_DELIMITER_DEFAULT)
					{
						cout << "readNLCflatfilePropertyLists() warning: reading " << fileName << " file and found delimiter: " << delimiter << endl;
					}
				}
			}

			//read header...
			vector<string> headerVariableList;

			bool foundHeader = true;
			int currentIndexInHeader = 0;
			bool stillFindingColumns = true;
			while(stillFindingColumns)
			{
				string currentVariableName = "";
				int nextIndexInHeader = currentLine.find(delimiter, currentIndexInHeader);
				if(nextIndexInHeader == CPP_STRING_FIND_RESULT_FAIL_VALUE)
				{
					stillFindingColumns = false;
					currentVariableName = currentLine.substr(currentIndexInHeader, currentLine.length()-currentIndexInHeader);
				}
				else
				{
					currentVariableName = currentLine.substr(currentIndexInHeader, nextIndexInHeader-currentIndexInHeader);
				}	
				
				if(variableNameIsAcceptableNLCclassName(currentVariableName))
				{
					#ifdef NLC_DEBUG_LIBRARY
					cout << "readNLCflatfilePropertyLists() reading header; currentVariableName = " << currentVariableName << endl;
					#endif		
					headerVariableList.push_back(currentVariableName);
					currentIndexInHeader = nextIndexInHeader+1;
				}
				else
				{
					#ifdef NLC_ALLOW_ALPHANUMERIC_CLASS_NAMES
					cout << "readNLCflatfilePropertyLists() error: reading " << fileName << " file and header variable does not contain alphabetic characters: " << currentVariableName << endl;
					#else
					cout << "readNLCflatfilePropertyLists() error: reading " << fileName << " file and header variable contains numeric characters:" << currentVariableName << endl;
					#endif
					foundHeader = false;
					result = false;
				}
			}
			
			if(foundHeader)	//NB if there is no header and each variable only contains letters, then NLC will fail to parse the file (it will treat the first line as the header)
			{
				int numberOfVariables = headerVariableList.size();
				
				//read contents...
				while(getline(parseFileObject, currentLine))
				{
					lineIndex++;
					vector<string> lineVariableList;
					int currentIndexInContents = 0;
					for(int i=0; i<numberOfVariables; i++)
					{
						string currentVariable = "";
						int nextIndexInContents = currentLine.find(delimiter, currentIndexInContents);
						if(nextIndexInContents == CPP_STRING_FIND_RESULT_FAIL_VALUE)
						{
							stillFindingColumns = false;
							currentVariable = currentLine.substr(currentIndexInContents, currentLine.length()-currentIndexInContents);
						}
						else
						{
							currentVariable = currentLine.substr(currentIndexInContents, nextIndexInContents-currentIndexInContents);
						}
						#ifdef NLC_DEBUG_LIBRARY
						cout << "readNLCflatfilePropertyLists() reading line; currentVariable = " << currentVariable << endl;
						#endif
						lineVariableList.push_back(currentVariable);
						currentIndexInContents = nextIndexInContents+1;
					}
					
					//cout << "lineVariableList.size() = " << lineVariableList.size() << endl;
					//cout << "numberOfVariables = " << numberOfVariables << endl;
					
					if(lineVariableList.size() == numberOfVariables)
					{	
						NLCgenericEntityClass* parentObject = generateObjectByName(parentObjectName);		//create a new parent object for the row
						readObjectClassList->push_back(parentObject);
						//cout << "parentObject = " << parentObject->name << endl;
						 													
						vector<string>::iterator iter1 = headerVariableList.begin();
						vector<string>::iterator iter2 = lineVariableList.begin();
						for(int i=0; i<numberOfVariables; i++)
						{
							string variableName = *iter1;
							string variableValue = *iter2;
							
							NLCgenericEntityClass* readObject = generateObjectByName(variableName);
							if(readObject == NULL)
							{
								cout << "readNLCflatfilePropertyLists() warning: reading a property (class) which is never used by user NLC code. Dropping data." << endl;
							}
							else
							{
								bool saveVariable = true;
								if(stringContainsNumbers(variableValue) && !stringContainsAlphabetic(variableValue))
								{
									readObject->mathObjectNumericalValue = SHAREDvarsClass().convertStringToDouble(variableValue);
									readObject->mathObjectType = NLC_MATH_OBJECTS_VARIABLE_TYPE_NUMERICAL;
								}
								#ifdef NLC_MATH_OBJECTS_ADVANCED
								#ifdef NLC_MATH_OBJECTS_STRING
								else if((variableValue.length() >= 3) && (variableValue[0] == NLC_MATH_OBJECTS_STRING_DELIMITER_CHAR) && (variableValue[variableValue.length()-1] == NLC_MATH_OBJECTS_STRING_DELIMITER_CHAR))
								{
									readObject->mathObjectStringValue = variableValue.substr(1, variableValue.length()-2);
									readObject->mathObjectType = NLC_MATH_OBJECTS_VARIABLE_TYPE_STRING;
									#ifdef NLC_DEBUG_LIBRARY
									cout << "readNLCflatfilePropertyLists(): readObject->mathObjectStringValue = " << readObject->mathObjectStringValue << endl;
									#endif
								}
								#endif
								#endif
								else if(variableValue == NLC_LIBRARY_FILEIO_FLAT_PRESENT_PROPERTY_VALUE)
								{
									//no additional information is added to the variable
								}
								else if(variableValue == NLC_LIBRARY_FILEIO_FLAT_NULL_PROPERTY_VALUE)
								{
									saveVariable = false;
								}
								else
								{
									readObject->aliasList.push_back(variableValue);	//CHECKTHIS
								}

								if(saveVariable)
								{
									vector<NLCgenericEntityClass*>* propertyList = getPropertyListByName(parentObject, variableName);	
									if(propertyList == NULL)
									{
										//IMPORTANT: drop data if fail to find the required property list (eg when reading in variables that are never used by user NLC code) 
										cout << "readNLCflatfilePropertyLists() warning: " << parentObjectName << " does not contain a " << variableName << " property list (eg reading a property which is never used by user NLC code). Dropping data." << endl;
									}
									else
									{
										propertyList->push_back(readObject);
									}

									#ifdef NLC_DEBUG_LIBRARY
									cout << "readNLCflatfilePropertyLists() reading cell; variableName = " << variableName << ", variableValue = " << variableValue << endl;
									#endif
								}
							}

							iter1++;
							iter2++;
						}
					}
					else
					{
						cout << "readNLCflatfilePropertyLists() error: reading " << fileName << " file and (lineVariableList.size() != headerVariableList.size()), lineIndex = " << lineIndex << endl;
						result = false;
					}
				}
			}
		}
		else
		{
			cout << "readNLCflatfilePropertyLists() error: reading " << fileName << " file; file only has one line (no header or contents detected)" << endl;
			result = false;
		}
	}
		
	return result;
}

bool variableNameIsAcceptableNLCclassName(string currentVariableName)
{
	bool result = false;
	#ifdef NLC_ALLOW_ALPHANUMERIC_CLASS_NAMES
	if(stringContainsAlphabetic(currentVariableName))
	#else
	if(!stringContainsNumbers(currentVariableName))
	#endif
	{
		result = true;
	}
}
			
bool stringContainsNumbers(string s)
{
	bool result = false;
	for(int i=0; i<NLC_LIBRARY_FILEIO_FLAT_NUMBER_OF_NUMERICAL_CHARACTERS; i++)
	{
		if(s.find(nlcLibraryFileIOflatFileNumericalCharacters[i]) == CPP_STRING_FIND_RESULT_FAIL_VALUE)
		{
			result = true;
		}	
	}
	return result;
}		

bool stringContainsAlphabetic(string s)
{
	bool result = false;
	for(int i=0; i<NLC_LIBRARY_FILEIO_FLAT_NUMBER_OF_ALPHABETIC_CHARACTERS; i++)
	{
		if(s.find(nlcLibraryFileIOflatFileAlphabeticCharacters[i]) == CPP_STRING_FIND_RESULT_FAIL_VALUE)
		{
			result = true;
		}	
	}
	return result;
}	
