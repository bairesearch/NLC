/*******************************************************************************
 *
 * This file is part of BAIPROJECT.
 *
 * BAIPROJECT is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License version 3
 * only, as published by the Free Software Foundation. The use of
 * intermediary programs or interfaces including file i/o is considered
 * remote network interaction. This does not imply such arrangements
 * do not constitute derivative works.
 *
 * BAIPROJECT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Affero General Public License
 * version 3 along with BAIPROJECT.  If not, see <http://www.gnu.org/licenses/>
 * for a copy of the AGPLv3 License.
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: NLClibraryGenericEntityClass.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2016 Baxter AI (baxterai.com)
 * Project: Natural Language Compiler (Programming Interface)
 * Project Version: 1u1c 24-September-2016
 * Requirements: requires C++ code to be generated by NLC
 *
 *******************************************************************************/
 
#include "NLClibraryGenericEntityClass.hpp"

NLCgenericEntityClass::NLCgenericEntityClass(void)
{
	name = "NLCgenericEntity";
	#ifdef NLC_USE_MATH_OBJECTS
	numericalValue = numeric_limits<double>::quiet_NaN();
	#ifdef NLC_USE_MATH_OBJECTS_ADVANCED
	#ifdef NLC_USE_MATH_OBJECTS_STRING
	stringValue = "";
	#endif
	#ifdef NLC_USE_MATH_OBJECTS_BOOLEAN
	booleanValue = false;
	#endif
	#endif
	#endif
	#ifdef NLC_NORMALISE_TWOWAY_PREPOSITIONS_MARK_INVERSE_CONDITIONS
	inverseConditionTwoWay = false;
	#endif
		
	#ifdef NLC_USE_ENUM_LISTS 
	enumType = NLC_ENUM_LIST_TYPE_DEFAULT_NON_ENUM;
	#endif
	
	#ifdef NLC_API
	thirdpartyAPIobject = NULL;
	#endif
};

#ifdef NLC_USE_ENUM_LISTS
#ifdef NLC_USE_ENUM_LISTS_PROPERTIES
unordered_map<string, string> enumTypeTableProperties;	//generated from NLCrules.xml (used for quick determination of enumType based on entity name)
#endif
#ifdef NLC_USE_ENUM_LISTS_CONDITIONS
unordered_map<string, string> enumTypeTableConditions;	//generated from NLCrules.xml (used for quick determination of enumType based on entity name)
#endif
#ifdef NLC_USE_ENUM_LISTS_ACTIONS
unordered_map<string, string> enumTypeTableActions;	//generated from NLCrules.xml (used for quick determination of enumType based on entity name)
#endif
#endif

#ifdef NLC_USE_ENUM_LISTS
#ifdef NLC_USE_ENUM_LISTS_PROPERTIES
string calculateEnumTypeProperty(string entityName)
{
	string enumType = NLC_ENUM_LIST_TYPE_DEFAULT_NON_ENUM;
	unordered_map<string, string>::iterator enumTypeTablePropertiesIter = enumTypeTableProperties.find(entityName);
	if(enumTypeTablePropertiesIter != enumTypeTableProperties.end())
	{
		enumType = enumTypeTablePropertiesIter->second;
	}
	return enumType;
}
#endif
#ifdef NLC_USE_ENUM_LISTS_CONDITIONS
string calculateEnumTypeCondition(string entityName)
{
	string enumType = NLC_ENUM_LIST_TYPE_DEFAULT_NON_ENUM;
	unordered_map<string, string>::iterator enumTypeTableConditionsIter = enumTypeTableConditions.find(entityName);
	if(enumTypeTableConditionsIter != enumTypeTableConditions.end())
	{
		enumType = enumTypeTableConditionsIter->second;
	}
	return enumType;
}
#endif
#endif

#ifdef NLC_SUPPORT_REDEFINITIONS
//must embed this function in NLCprintCodeBlocks.cpp code;
bool checkParentClassName(NLCgenericEntityClass* object, string className)
{
	bool result = false;
	if(object->name == className)
	{
		result = true;
	}
	for(vector<NLCgenericEntityClass*>::iterator iter1 = object->parentClassList.begin(); iter1 < object->parentClassList.end(); iter1++) 
	{
		NLCgenericEntityClass* parent = *iter1;
		if(checkParentClassName(parent, className))
		{
			result = true;
		}
	}
	return result;
}
#endif
#ifdef NLC_USE_ADVANCED_REFERENCING_MONITOR_CONTEXT
void addEntityToReferenceContextList(vector<NLCgenericEntityClass*>& referenceContextList, NLCgenericEntityClass* NLCgenericEntity, int sentenceIndex)
{
	referenceContextList.push_back(NLCgenericEntity);
	NLCgenericEntity->lastSentenceReferenced.push(sentenceIndex);
}

void clearReferenceContextList(vector<NLCgenericEntityClass*>& referenceContextList)
{
	for(vector<NLCgenericEntityClass*>::iterator iter1 = referenceContextList.begin(); iter1 < referenceContextList.end(); iter1++) 
	{
		NLCgenericEntityClass* NLCgenericEntity = *iter1;
		NLCgenericEntity->lastSentenceReferenced.pop();
	}
	referenceContextList.clear();
}
#endif

#ifdef NLC_USE_MATH_OBJECTS_ADVANCED

#ifdef NLC_USE_MATH_OBJECTS_ADVANCED_DYNAMIC_DETERMINE_MATH_OBJECT_VARIABLE_TYPE
void detectMathObjectVariableType(NLCgenericEntityClass* object, double* mathObjectVariableNumericalPointer, string* mathObjectVariableStringPointer, int* sentenceMathObjectVariableType)
{
	if(object->numericalValue != numeric_limits<double>::quiet_NaN())
	{
		*sentenceMathObjectVariableType = NLC_USE_MATH_OBJECTS_VARIABLE_TYPE_NUMERICAL;
	}
	else if(object->stringValue != "")
	{
		*sentenceMathObjectVariableType = NLC_USE_MATH_OBJECTS_VARIABLE_TYPE_STRING;
	}
	else
	{
		//cout << "detectMathObjectVariableType{} warning: cannot detect math object variable type for object; object->name = " << object->name<< endl; 
	}
	*mathObjectVariableNumericalPointer = object->numericalValue;
	*mathObjectVariableStringPointer = object->stringValue;
}

/*
int detectMathObjectVariableType(NLCgenericEntityClass* object)
{
	int mathObjectVariableType = NLC_USE_MATH_OBJECTS_VARIABLE_TYPE_UNKNOWN;
	if(object->numericalValue != numeric_limits<double>::quiet_NaN())
	{
		mathObjectVariableType = NLC_USE_MATH_OBJECTS_VARIABLE_TYPE_NUMERICAL;
	}
	else if(object->stringValue != "")
	{
		mathObjectVariableType = NLC_USE_MATH_OBJECTS_VARIABLE_TYPE_STRING;	
	}
	else
	{
		//cout << "detectMathObjectVariableType{} warning: cannot detect math object variable type for object; object->name = " << object->name<< endl; 
	}
	return mathObjectVariableType;
}
*/
#endif

void assignMathObjectValue(NLCgenericEntityClass* targetObject, NLCgenericEntityClass* sourceObject)
{
	if(sourceObject->numericalValue != numeric_limits<double>::quiet_NaN())
	{
		targetObject->numericalValue = sourceObject->numericalValue;
	}
	else if(sourceObject->stringValue != "")
	{
		targetObject->stringValue = sourceObject->stringValue;
	}
	else
	{
		cout << "assignMathObjectValue{} error: assigning mathobject value but no numerical or text value found for source object; sourceObject->name = " << sourceObject->name << endl; 
	}
}
void assignMathObjectValue(NLCgenericEntityClass* targetObject, double sourceObjectNumerical)
{	
	targetObject->numericalValue = sourceObjectNumerical;
}
#ifdef NLC_USE_MATH_OBJECTS_STRING
void assignMathObjectValue(NLCgenericEntityClass* targetObject, string sourceObjectString)
{	
	targetObject->stringValue = sourceObjectString;
}
#endif
#ifdef NLC_USE_MATH_OBJECTS_BOOLEAN
void assignMathObjectValue(NLCgenericEntityClass* targetObject, bool sourceObjectBoolean)
{	
	targetObject->booleanValue = sourceObjectBoolean;
}
#endif

#ifdef NLC_USE_MATH_OBJECTS_ADVANCED_ASSIGN_MATHTEXT_VALUE_FUNCTION
void assignMathTextValue(double* targetObject, NLCgenericEntityClass* sourceObject)
{
	*targetObject = sourceObject->numericalValue;
}
#ifdef NLC_USE_MATH_OBJECTS_STRING
void assignMathTextValue(string* targetObject, NLCgenericEntityClass* sourceObject)
{
	*targetObject = sourceObject->stringValue;
}
#endif
#ifdef NLC_USE_MATH_OBJECTS_BOOLEAN
void assignMathTextValue(bool* targetObject, NLCgenericEntityClass* sourceObject)
{
	*targetObject = sourceObject->booleanValue;
}
#endif
#else
double getMathObjectValue(NLCgenericEntityClass* targetObject)
{
	return targetObject->numericalValue;
}
#ifdef NLC_USE_MATH_OBJECTS_STRING
string getMathObjectValue(NLCgenericEntityClass* targetObject)
{
	return targetObject->stringValue;	
}
#endif
#ifdef NLC_USE_MATH_OBJECTS_BOOLEAN
bool getMathObjectValue(NLCgenericEntityClass* targetObject)
{
	return targetObject->booleanValue;	
}
#endif
#endif

#ifndef NLC_USE_MATH_OBJECTS_ADVANCED_USE_UNIQUE_OPERATORS
#ifdef NLC_USE_MATH_OBJECTS_ADVANCED_ADDITIONS
NLCgenericEntityClass* addMathObjectValue(NLCgenericEntityClass* objectA, NLCgenericEntityClass* objectB)
{
	NLCgenericEntityClass* newEntity = new NLCgenericEntityClass();
	if(objectA->numericalValue != numeric_limits<double>::quiet_NaN())
	{
		newEntity->numericalValue = objectA->numericalValue + objectB->numericalValue;
	}
	#ifdef NLC_USE_MATH_OBJECTS_STRING
	else if(objectA->stringValue != "")
	{
		newEntity->stringValue = objectA->stringValue + objectB->stringValue;
	}
	#endif
	else if(objectB->numericalValue != numeric_limits<double>::quiet_NaN())
	{
		newEntity->numericalValue = objectA->numericalValue + objectB->numericalValue;
	}
	#ifdef NLC_USE_MATH_OBJECTS_STRING
	else if(objectB->stringValue != "")
	{
		newEntity->stringValue = objectA->stringValue + objectB->stringValue;
	}
	#endif
	else
	{
		cout << "addMathObjectValue{} error: adding mathobject value but no numerical or text value found for either object; objectA->name = " << objectA->name << ", objectB->name = " << objectB->name << endl; 
	}
	return newEntity;
	
}
NLCgenericEntityClass* addMathObjectValue(double objectA, NLCgenericEntityClass* objectB)
{
	NLCgenericEntityClass* newEntity = new NLCgenericEntityClass();
	newEntity->numericalValue = objectA + objectB->numericalValue;
	return newEntity;
}
NLCgenericEntityClass* addMathObjectValue(NLCgenericEntityClass* objectA, double objectB)
{
	NLCgenericEntityClass* newEntity = new NLCgenericEntityClass();
	newEntity->numericalValue = objectA->numericalValue + objectB;
	return newEntity;
}
NLCgenericEntityClass* addMathObjectValue(double objectA, double objectB)
{
	NLCgenericEntityClass* newEntity = new NLCgenericEntityClass();
	newEntity->numericalValue = objectA + objectB;
	return newEntity;
}
#ifdef NLC_USE_MATH_OBJECTS_STRING
NLCgenericEntityClass* addMathObjectValue(string objectA, NLCgenericEntityClass* objectB)
{
	NLCgenericEntityClass* newEntity = new NLCgenericEntityClass();
	newEntity->stringValue = objectA + objectB->stringValue;
	return newEntity;
}
NLCgenericEntityClass* addMathObjectValue(NLCgenericEntityClass* objectA, string objectB)
{
	NLCgenericEntityClass* newEntity = new NLCgenericEntityClass();
	newEntity->stringValue = objectA->stringValue + objectB;
	return newEntity;
}
NLCgenericEntityClass* addMathObjectValue(string objectA, string objectB)
{
	NLCgenericEntityClass* newEntity = new NLCgenericEntityClass();
	newEntity->stringValue = objectA + objectB;
	return newEntity;
}
#endif
#endif
#ifdef NLC_USE_MATH_OBJECTS_ADVANCED_COMPARISONS
bool testMathObjectValue(NLCgenericEntityClass* targetObject, NLCgenericEntityClass* sourceObject)
{
	bool testResult = false;
	int mathObjectVariableType = NLC_USE_MATH_OBJECTS_VARIABLE_TYPE_UNKNOWN;
	if(sourceObject->numericalValue != numeric_limits<double>::quiet_NaN())
	{
		if(targetObject->numericalValue != numeric_limits<double>::quiet_NaN())
		{
			mathObjectVariableType = NLC_USE_MATH_OBJECTS_VARIABLE_TYPE_NUMERICAL;
			testResult = testMathObjectValue(sourceObject->numericalValue, targetObject->numericalValue);
		}
		else
		{
			cout << "testMathObjectValue{} error: testing mathobject value but no numerical or text value found for source and/or target object; sourceObject->name = " << sourceObject->name << ", targetObject->name = " << targetObject->name << endl; 
		}
	}
	#ifdef NLC_USE_MATH_OBJECTS_STRING
	else if(sourceObject->stringValue != "")
	{
		if(targetObject->stringValue != "")
		{
			mathObjectVariableType = NLC_USE_MATH_OBJECTS_VARIABLE_TYPE_STRING;
			testResult = testMathObjectValue(sourceObject->stringValue, targetObject->stringValue);
			
		}
		else
		{
			cout << "testMathObjectValue{} error: testing mathobject value but no numerical or text value found for source and/or target object; sourceObject->name = " << sourceObject->name << ", targetObject->name = " << targetObject->name << endl; 	
		}
	}
	#endif
	else
	{
		cout << "testMathObjectValue{} error: testing mathobject value but no numerical or text value found for source and/or target object; sourceObject->name = " << sourceObject->name << ", targetObject->name = " << targetObject->name << endl; 
	}
	return testResult;
}
//NB supported testExpression values: NLC_PREPROCESSOR_MATH_OPERATOR_EQUALS_TEST/NLC_PREPROCESSOR_MATH_OPERATOR_GREATER_THAN/NLC_PREPROCESSOR_MATH_OPERATOR_LESS_THAN/NLC_PREPROCESSOR_MATH_OPERATOR_GREATER_THAN_OR_EQUAL_TO/NLC_PREPROCESSOR_MATH_OPERATOR_LESS_THAN_OR_EQUAL_TO/NLC_PREPROCESSOR_MATH_OPERATOR_DOES_NOT_EQUAL
bool testMathObjectValue(NLCgenericEntityClass* targetObject, double sourceObject)
{
	return testMathObjectValue(targetObject->numericalValue, sourceObject);
}
bool testMathObjectValue(double targetObject, NLCgenericEntityClass* sourceObject)
{
	return testMathObjectValue(targetObject, sourceObject->numericalValue);
}
bool testMathObjectValue(double targetObject, double sourceObject)
{
	bool testResult = (targetObject == sourceObject);
	return testResult;					
}
#ifdef NLC_USE_MATH_OBJECTS_STRING
//NB supported testExpression values: NLC_PREPROCESSOR_MATH_OPERATOR_EQUALS_TEST
bool testMathObjectValue(NLCgenericEntityClass* targetObject, string sourceObject)
{
	return testMathObjectValue(targetObject->stringValue, sourceObject);
}
bool testMathObjectValue(string targetObject, NLCgenericEntityClass* sourceObject)
{
	return testMathObjectValue(targetObject, sourceObject->stringValue);
}
bool testMathObjectValue(string targetObject, string sourceObject)
{
	bool testResult = (targetObject == sourceObject);
	return testResult;
}
#endif
#ifdef NLC_USE_MATH_OBJECTS_BOOLEAN
bool testMathObjectValue(NLCgenericEntityClass* targetObject, bool sourceObject)
{
	return testMathObjectValue(targetObject->booleanValue, sourceObject);
}
bool testMathObjectValue(bool targetObject, NLCgenericEntityClass* sourceObject)
{
	return testMathObjectValue(targetObject, sourceObject->booleanValue);
}
bool testMathObjectValue(bool targetObject, bool sourceObject)
{
	bool testResult = (targetObject == sourceObject);
	return testResult;
}
bool testMathObjectValue(NLCgenericEntityClass* object)
{
	//boolean expression, eg "the red button" (theredbutton)
	bool testResult = object->booleanValue;
		
	//note boolean statement expressions are not parsed by testMathObjectValue eg if(testMathObjectValue(theredchickenisnexttothehouse)), they are parsed directly eg if(theredchickenisnexttothehouse)
	/*
	//boolean statement expression, eg "the red chicken is next to the house" (theredchickenisnexttothehouse) <- NB boolean expressions contain the auxiliary "is"
	if(object != NULL)
	{
		testResult = true;	//NLC successfully found and set the object pointer when parsing the parsable phrase
	}
	*/
	
	return testResult;
}
#endif
#endif
#endif

#endif
