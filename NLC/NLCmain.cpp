/*******************************************************************************
 *
 * No License
 * 
 * This work is under exclusive copyright (c) Baxter AI (baxterai.com). 
 * Nobody else can use, copy, distribute, or modify this work without being 
 * at risk of take-downs, shake-downs, or litigation. 
 * 
 * By publishing this source code in a public repository on GitHub, Terms of 
 * Service have been accepted by which Baxter AI have allowed others to view 
 * and fork their repository.
 * 
 * If you find software that doesn't have a license, that generally means you 
 * have no permission from the creators of the software to use, modify, or 
 * share the software. Although a code host such as GitHub may allow you to 
 * view and fork the code, this does not imply that you are permitted to use, 
 * modify, or share the software for any purpose.
 *
 * This notice has been derived from https://choosealicense.com/no-permission 
 * (https://web.archive.org/web/20180312144938/https://choosealicense.com/no-permission)
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: NLCmain.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2019 Baxter AI (baxterai.com)
 * Project: Natural Language Compiler
 * Project Version: 2g1a 03-January-2019
 * Requirements: requires text parsed by BAI General Intelligence Algorithm (GIA)
 * /
 *******************************************************************************/


#include "NLCmain.hpp"

static char errmessage[] = "Usage:  NLC.exe [options]\n\n\twhere options are any of the following\n"
"\n\t-inlc [string]     : plain text .nlc input filename to be parsed by NLC/GIA (def: inputText.nlc)"
#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
"\n\t-inlcp [string]	: file list (new line delimited) referencing nlc file names (def: inputFileList.nlcp)"
#endif
#ifdef NLC_PREPROCESSOR
"\n\t-ipreprocess	: input file(s) will be preprocessed, supporting condition block indentation (eg if the ball is red\\n\\tthe stars are bright\\n\\tthe cat is happy) and multiple functions (delimited by 'function [functionSubject#]functionName)[+functionObject]'"
#endif
#ifdef NLC_API
"\n\t-api                       : expose third party API (wrap with NLC code) using doxygen xml output"
"\n\t-apisourcefolder [string]  : location of third party API source code (def: /home/systemusername/source/doxygen)"
"\n\t-apiclasslist [string]   	: third party API class list (def: apiClassList.txt)"
#endif
"\n\t-onlprel [string]  : NLP dependency relation parser .xml intermediary output filename (def: inputNLPrelation.xml)"
"\n\t-onlptag [string]  : NLP feature tag parser .xml intermediary output filename (def: inputNLPfeature.xml)"
"\n\t-oxml [string]     : semantic network definition .xml output filename (def: semanticNet.xml)"
"\n\t-ocxl [string]     : semantic network display .cxl vector graphics output filename (def: semanticNet.cxl)"
"\n\t-osvg [string]     : semantic network display .svg 2D vector graphics output filename (def: semanticNet.svg)"
"\n\t-oldr [string]     : semantic network display .ldr 3D vector graphics output filename (def: semanticNet.ldr)"
"\n\t-oppm [string]     : semantic network display .ppm raster graphics output filename (def: semanticNet.ppm)"
"\n\t-ocff [string]     : NLP parser generated .cff output filename (def: outputNLP.cff)"
"\n\t-oall [string]     : semantic network display xml/.svg/.ldr/.ppm default generic output filename (def: semanticNet)"
"\n\t-show              : display output in opengl"
"\n\t-width [int]       : raster graphics width in pixels (def: 640)"
"\n\t-height [int]      : raster graphics height in pixels (def: 480)"
"\n\t-nlprelation [int] : NLP dependency relation parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP, 2 - Stanford Parser [def])"
"\n\t-nlpfeature [int]  : NLP feature parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP [def], 2 - Stanford Parser (ie, none))"
"\n\t-nlpcompmode [int] : sets Relex into Stanford compatibility mode (0 - off [def], 1 - (assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode, 2 - assumes Relex dependency relations were generated by GIA in cff) [UNTESTED]"
#ifdef GIA_DATABASE
"\n\t-dbread            : read from database (GIA knowledge base) [improves referencing capacity]"
"\n\t-dbwrite           : write to database (GIA knowledge base) [saves knowledge]"
"\n\t-dbfolder          : database base folder path (def: /home/systemusername/source/GIAKBdatabase)"
#endif
#ifdef GIA_SEM_REL_TRANSLATOR
"\n\t-dbsemanticparserfolder    : direct semantic parser (corpus or optimised) database base folder path (def: /home/systemusername/source/GIAsemanticparserdatabase)"
#endif
#ifdef GIA_PREPROCESSOR
"\n\t-lrp                               : language reduction preprocessor"
"\n\t-olrptxt [string]                  : plain text .txt output filename with GIA language reduction preprocessor applied (def: inputTextWithLRP.txt)"
"\n\t-lrpfolder                         : folder of LRP data files (list of multiword verbs, multiword prepositions etc) (def: same as exe)"
#endif
#ifdef USE_WORDNET
"\n\t-syndet                            : wordnet synonymn detection (0 - off, 1 - during queries only, 2 - during referencing and queries [def])"
#endif
"\n"
"\n\t-inputfolder [string]              : input directory name for input files (def: same as exe)"
"\n\t-nlprelexfolder [string]           : directory name for Relex (def: same as exe)"
"\n\t-nlpstanfordcorenlpfolder [string] : directory name for Stanford Parser (def: same as exe)"
"\n\t-nlpstanfordparserfolder [string]  : directory name for Stanford CoreNLP (def: same as exe)"
#ifdef GIA_NLP_CLIENT_SERVER
"\n\t-nlpclient                         : execute NLP as client (requires server to be already started)"
#endif
"\n\t-outputfolder [string]             : output directory name for temporary and output files (def: same as exe)"
"\n"
"\n\n\t-version         : print version"
"\n\n\tThis program performs NLC (Natural Language Compiler) operations - generates computer code (eg C++) from natural language statements (it currently requires to be compiled with GIA source code).\n\n";

#ifdef COMPILE_NLC
int main(const int argc, const char** argv)
{
	bool result = true;

	#ifdef NLC_PRINT_EXECUTION_TIME
	SHAREDvarsClass().printTime("NLC execution time: ", " (start)");
	#endif
	
	string currentFolder = SHAREDvarsClass().getCurrentDirectory();
	string inputFolderLocal = currentFolder;
	string outputFolderLocal = currentFolder;
	
	int NLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_TEXT_DEFAULT;
	int NLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_TEXT_DEFAULT;
	bool NLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool NLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff
	#ifdef GIA_NLP_CLIENT_SERVER
	bool NLPclient = false;
	#endif
	
	string NLPexeFolderArray[GIA_NLP_PARSER_NUMBER_OF_TYPES];

	bool useInputTextPlainTXTFile = false;
	string inputTextPlainTXTfileName = "inputText.nlc";
	#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
	bool useNLCinputFileList = false;
	string NLCinputFileListName = "inputFileList.nlcp";
	#endif
	
	string outputTextNLPrelationXMLfileName = "inputNLPrelation.xml";
	string outputTextNLPfeatureXMLfileName = "inputNLPfeature.xml";
	bool useOutputTextCFFFile = false;
	string outputTextCFFFileName = "outputNLP.cff";
	bool useOutputTextXMLFile = false;
	string outputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextCXLFile = false;
	string outputTextCXLFileName = "semanticNet.cxl";
	bool useOutputTextLDRFile = false;
	string outputTextLDRFileName = "semanticNet.ldr";
	bool useOutputTextPPMFile = false;
	string outputTextPPMFileName = "semanticNet.ppm";
	bool useOutputTextSVGFile = false;
	string outputTextSVGFileName = "semanticNet.svg";

	bool useOutputTextAllFile = false;
	string outputTextAllFileName = "semanticNet";

	//#ifdef NLC_PREPROCESSOR
	bool useNLCpreprocessor = false;
	//#endif
	#ifdef NLC_API
	bool NLCapi = false;
	string APIsourceFolder = NLC_API_DEFAULT_SOURCE_FOLDER_NAME;
	string APIclassListFileName = NLC_API_DEFAULT_CLASS_LIST_FILE_NAME;
	#endif

	bool printOutput = false;
	bool displayInOpenGLAndOutputScreenshot = false;

	int rasterImageWidth = 640;
	int rasterImageHeight = 480;


	#ifdef GIA_DATABASE
	bool readFromDatabase = false;
	bool writeToDatabase = false;
	bool useDatabase = false;
	string KBdatabaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
	#endif
	#ifdef GIA_SEM_REL_TRANSLATOR
	string semanticParserDatabaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_SEM_REL_TRANSLATOR_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
	#endif
	#ifdef GIA_PREPROCESSOR_POS_TAGGER_DATABASE_PERSISTENT
	string POStaggerDatabaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_PREPROCESSOR_POS_TAGGER_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
	#endif
	
	#ifdef GIA_PREPROCESSOR
	bool useLRP = false;
	bool useOutputLRPTextPlainTXTFile = false;
	string outputLRPTextPlainTXTFileName = "inputTextWithLRP.txt";
	string lrpDataFolderName = "";
	#endif

	#ifdef USE_WORDNET
	#ifdef GIA_SYNONYMN_DETECTION_DEFAULT_QUERIES_AND_ADVANCED_REFERENCING
	int synonymnDetectionStatus = SYNONYMN_DETECTION_STATUS_QUERIES_AND_ADVANCED_REFERENCING;
	#else
	int synonymnDetectionStatus = SYNONYMN_DETECTION_STATUS_QUERIES_ONLY;
	#endif
	#endif

	//bool train = false;
	//bool form = true;

	//basic execution flow outline; if no dataset or xml inputText file is specified, just form network - do not train network

	if(SHAREDvarsClass().argumentExists(argc, argv, "-inlc") || SHAREDvarsClass().argumentExists(argc, argv, "-inlcp") || SHAREDvarsClass().argumentExists(argc, argv, "-itxt"))
	{
		if(SHAREDvarsClass().argumentExists(argc, argv, "-inlc"))
		{
			inputTextPlainTXTfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-inlc");
			useInputTextPlainTXTFile = true;
		}
		
		//for backwards compatibility:
		if(SHAREDvarsClass().argumentExists(argc, argv, "-itxt"))
		{
			inputTextPlainTXTfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-itxt");
			useInputTextPlainTXTFile = true;
			cout << "-itxt has been depreciated; please use -inlc instead." << endl;
		}

		#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
		if(SHAREDvarsClass().argumentExists(argc, argv, "-inlcp"))
		{
			NLCinputFileListName = SHAREDvarsClass().getStringArgument(argc, argv, "-inlcp");
			useNLCinputFileList = true;
		}
		#endif
		#ifdef NLC_PREPROCESSOR
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ipreprocess"))
		{
			useNLCpreprocessor = true;
		}
		#endif
		#ifdef NLC_API
		if(SHAREDvarsClass().argumentExists(argc, argv, "-api"))
		{
			NLCapi = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-apisourcefolder"))
		{
			APIsourceFolder = SHAREDvarsClass().getStringArgument(argc, argv, "-apisourcefolder");
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-apiclasslist"))
		{
			APIclassListFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-apiclasslist");
		}
		#endif

		if(SHAREDvarsClass().argumentExists(argc, argv, "-onlprel"))
		{
			outputTextNLPrelationXMLfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-onlprel");
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-onlptag"))
		{
			outputTextNLPfeatureXMLfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-onlptag");
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-oxml"))
		{
			outputTextXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oxml");
			useOutputTextXMLFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ocxl"))
		{
			outputTextCXLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ocxl");
			useOutputTextCXLFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-osvg"))
		{
			outputTextSVGFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-osvg");
			useOutputTextSVGFile = true;
			printOutput = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-oldr"))
		{
			outputTextLDRFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oldr");
			useOutputTextLDRFile = true;
			printOutput = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-oppm"))
		{
			outputTextPPMFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oppm");
			useOutputTextPPMFile = true;
			printOutput = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ocff"))
		{
			outputTextCFFFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ocff");
			useOutputTextCFFFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-oall"))
		{
			outputTextAllFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oall");
			useOutputTextAllFile = true;
			printOutput = true;
		}

		/*
		if(SHAREDvarsClass().argumentExists(argc, argv, "-train"))
		{
			int trainInt
			trainInt = SHAREDvarsClass().getFloatArgument(argc, argv, "-train");
			train = (bool)trainInt;
		}
		*/

		if(SHAREDvarsClass().argumentExists(argc, argv, "-show"))
		{
			displayInOpenGLAndOutputScreenshot = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-width"))
		{
			rasterImageWidth = SHAREDvarsClass().getFloatArgument(argc, argv, "-width");
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-height"))
		{
			rasterImageHeight = SHAREDvarsClass().getFloatArgument(argc, argv, "-height");
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlprelation"))
		{
			NLPdependencyRelationsParser = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlprelation"));
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpfeature"))
		{
			NLPfeatureParser = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlpfeature"));
		}
		else
		{
			NLPfeatureParser = NLPdependencyRelationsParser;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpcompmode"))
		{
			if(NLPdependencyRelationsParser == GIA_NLP_PARSER_RELEX)
			{
				int nlpcompmode = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlpcompmode"));
				if(nlpcompmode == 1)
				{
					NLPrelexCompatibilityMode = true;
					NLPassumePreCollapsedStanfordRelations = true;
				}
				else if(nlpcompmode == 2)
				{
					NLPassumePreCollapsedStanfordRelations = true;
				}
			}
			else
			{
				cerr << "error: nlpcompmode set but (NLPdependencyRelationsParser != GIA_NLP_PARSER_RELEX)" << endl;
				exit(EXIT_ERROR);
			}
		}

		#ifdef GIA_DATABASE
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbread"))
		{
			readFromDatabase = true;
			useDatabase = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbwrite"))
		{
			writeToDatabase = true;
			useDatabase = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbfolder"))
		{
			KBdatabaseFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-dbfolder");
		}
		#endif
		#ifdef GIA_SEM_REL_TRANSLATOR
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbsemanticparserfolder"))
		{
			semanticParserDatabaseFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-dbsemanticparserfolder");
		}
		#endif
		#ifdef GIA_PREPROCESSOR_POS_TAGGER_DATABASE_PERSISTENT
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbpostaggerfolder"))
		{
			POStaggerDatabaseFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-dbpostaggerfolder");
		}
		#endif
		
		#ifdef GIA_PREPROCESSOR
		if(SHAREDvarsClass().argumentExists(argc, argv, "-lrp"))
		{
			useLRP = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-olrptxt"))
		{
			outputLRPTextPlainTXTFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-olrptxt");
			useOutputLRPTextPlainTXTFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-lrpfolder"))
		{
			lrpDataFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-lrpfolder");
		}
		else
		{
			lrpDataFolderName = currentFolder;
		}
		#endif
		#ifdef USE_WORDNET
		if(SHAREDvarsClass().argumentExists(argc, argv, "-syndet"))
		{
			synonymnDetectionStatus = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-syndet"));
		}
		#endif

		if(SHAREDvarsClass().argumentExists(argc, argv, "-inputfolder"))
		{
			inputFolderLocal = SHAREDvarsClass().getStringArgument(argc, argv, "-inputfolder");
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlprelexfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlprelexfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] = currentFolder;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpstanfordcorenlpfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlpstanfordcorenlpfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] = currentFolder;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpstanfordparserfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlpstanfordparserfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] = currentFolder;
		}
		#ifdef GIA_NLP_CLIENT_SERVER
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpclient"))
		{
			NLPclient = true;
		}	
		#endif	
		

		if(SHAREDvarsClass().argumentExists(argc, argv, "-outputfolder"))
		{
			outputFolderLocal = SHAREDvarsClass().getStringArgument(argc, argv, "-outputfolder");
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-version"))
		{
			cout << "NLC.exe - Project Version: 2g1a 03-January-2019" << endl;
			exit(EXIT_OK);
		}


	}
	else
	{
		cerr << "error: GIA requires either a plain text inputText file (.txt), an NPL parsed inputText file (.xml) or GIA semantic network (.xml) to be defined" << endl;
		cerr << errmessage << endl;
		exit(EXIT_ERROR);
	}
	
	NLCfunction* firstNLCfunctionInList = NULL;
	GIAtranslatorVariablesClass* translatorVariablesTemplate = new GIAtranslatorVariablesClass();
	translatorVariablesTemplate->isQuery = false;
	translatorVariablesTemplate->entityNodesActiveListComplete = new vector<GIAentityNode*>;	//NOT USED
	translatorVariablesTemplate->entityNodesActiveListNetworkIndexes = new unordered_map<string, GIAentityNode*>;	//NOT USED
	translatorVariablesTemplate->timeConditionNodesActiveList = new unordered_map<int64_t, GIAtimeConditionNode*>;	//NOT USED
	translatorVariablesTemplate->entityNodesActiveListSentences = new map<int, vector<GIAentityNode*>*>;	//NOT USED
	translatorVariablesTemplate->NLPfeatureParser = NLPfeatureParser;
	translatorVariablesTemplate->NLPdependencyRelationsParser = NLPdependencyRelationsParser;
	translatorVariablesTemplate->NLPrelexCompatibilityMode = NLPrelexCompatibilityMode;
	translatorVariablesTemplate->NLPassumePreCollapsedStanfordRelations = NLPassumePreCollapsedStanfordRelations;
	#ifdef GIA_NEURAL_NETWORK
	translatorVariables->ANNfirstInputNeuronInNetwork = new ANNneuron();
	#endif
	#ifdef GIA_NLP_CLIENT_SERVER
	translatorVariablesTemplate->NLPclient = NLPclient;
	#endif
	SHAREDvarsClass().copyStringArray(NLPexeFolderArray, translatorVariablesTemplate->NLPexeFolderArray, GIA_NLP_PARSER_NUMBER_OF_TYPES);	

	NLCmainClass().executeNLC(

		firstNLCfunctionInList,
		translatorVariablesTemplate,

		inputFolderLocal, 
		outputFolderLocal,

		useInputTextPlainTXTFile,
		inputTextPlainTXTfileName,
		#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
		useNLCinputFileList,
		NLCinputFileListName,
		#endif
		
		outputTextNLPrelationXMLfileName,
		outputTextNLPfeatureXMLfileName,
		useOutputTextCFFFile,
		outputTextCFFFileName,
		useOutputTextXMLFile,
		outputTextXMLFileName,
		useOutputTextCXLFile,
		outputTextCXLFileName,
		useOutputTextLDRFile,
		outputTextLDRFileName,
		useOutputTextPPMFile,
		outputTextPPMFileName,
		useOutputTextSVGFile,
		outputTextSVGFileName,
		
		useOutputTextAllFile,
		outputTextAllFileName,

		//#ifdef NLC_PREPROCESSOR
		useNLCpreprocessor,
		//#endif
		#ifdef NLC_API
		NLCapi,
		APIsourceFolder,
		APIclassListFileName,
		#endif
	
		printOutput,
		displayInOpenGLAndOutputScreenshot,

		rasterImageWidth,
		rasterImageHeight,

		#ifdef GIA_DATABASE
		readFromDatabase,
		writeToDatabase,
		useDatabase,
		KBdatabaseFolderName,
		#endif
		#ifdef GIA_SEM_REL_TRANSLATOR
		semanticParserDatabaseFolderName,
		#endif
		#ifdef GIA_PREPROCESSOR_POS_TAGGER_DATABASE_PERSISTENT
		POStaggerDatabaseFolderName,
		#endif
		
		#ifdef GIA_PREPROCESSOR
		useLRP,
		useOutputLRPTextPlainTXTFile,
		outputLRPTextPlainTXTFileName,
		lrpDataFolderName,
		#endif

		#ifdef USE_WORDNET
		synonymnDetectionStatus
		#endif

	);	
	
	#ifdef NLC_PRINT_EXECUTION_TIME
	SHAREDvarsClass().printTime("NLC execution time: ", " (finish)");
	#endif
}
#endif

bool NLCmainClass::executeNLC(

	NLCfunction* firstNLCfunctionInList,
	GIAtranslatorVariablesClass* translatorVariablesTemplate,
			
	string inputFolderLocal, 
	string outputFolderLocal,

	bool useInputTextPlainTXTFile,
	string inputTextPlainTXTfileName,
	#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
	bool useNLCinputFileList,
	string NLCinputFileListName,
	#endif
		
	string outputTextNLPrelationXMLfileName,
	string outputTextNLPfeatureXMLfileName,
	bool useOutputTextCFFFile,
	string outputTextCFFFileName,
	bool useOutputTextXMLFile,
	string outputTextXMLFileName,
	bool useOutputTextCXLFile,
	string outputTextCXLFileName,
	bool useOutputTextLDRFile,
	string outputTextLDRFileName,
	bool useOutputTextPPMFile,
	string outputTextPPMFileName,
	bool useOutputTextSVGFile,
	string outputTextSVGFileName,
	
	bool useOutputTextAllFile,
	string outputTextAllFileName,

	//#ifdef NLC_PREPROCESSOR
	bool useNLCpreprocessor,
	//#endif
	#ifdef NLC_API
	bool NLCapi,
	string APIsourceFolder,
	string APIclassListFileName,
	#endif
	
	bool printOutput,
	bool displayInOpenGLAndOutputScreenshot,

	int rasterImageWidth,
	int rasterImageHeight,

	#ifdef GIA_DATABASE
	bool readFromDatabase,
	bool writeToDatabase,
	bool useDatabase,
	string KBdatabaseFolderName,
	#endif
	#ifdef GIA_SEM_REL_TRANSLATOR
	string semanticParserDatabaseFolderName,
	#endif
	#ifdef GIA_PREPROCESSOR_POS_TAGGER_DATABASE_PERSISTENT
	string POStaggerDatabaseFolderName,
	#endif
		
	#ifdef GIA_PREPROCESSOR
	bool useLRP,
	bool useOutputLRPTextPlainTXTFile,
	string outputLRPTextPlainTXTFileName,
	string lrpDataFolderName,
	#endif

	#ifdef USE_WORDNET
	int synonymnDetectionStatus
	#endif
	)
{
#ifdef USE_CS_WORKAROUND
}
bool NLCmainClass::executeNLC2()
{
#endif
	bool result = true;

	inputFolder = inputFolderLocal;
	outputFolder = outputFolderLocal;
	SHAREDvarsClass().setCurrentDirectory(inputFolder);
	
	int progLang = NLC_PROGRAMMING_LANGUAGE_DEFAULT;
	NLCprintDefsClass().setProgLang(progLang);

	bool useInputTextNLPrelationXMLFile = false;
	string inputTextNLPrelationXMLfileName = outputTextNLPrelationXMLfileName;
	bool useInputTextNLPfeatureXMLFile = false;
	string inputTextNLPfeatureXMLfileName = outputTextNLPfeatureXMLfileName;
	bool useInputTextXMLFile = false;
	string inputTextXMLFileName = "semanticNet.xml";
		
	//GIA variables not used by NLC;
	int queryNLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_QUERY_DEFAULT;
	int queryNLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_QUERY_DEFAULT;
	bool queryNLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool queryNLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff
	bool useInputQueryPlainTXTFile = false;
	string inputQueryPlainTXTFileName = "inputTextQuery.txt";
	bool useInputQueryNLPrelationXMLFile = false;
	string inputQueryNLPrelationXMLFileName = "inputNLPrelationQuery.xml";
	bool useInputQueryNLPfeatureXMLFile = false;
	string inputQueryNLPfeatureXMLFileName = "inputNLPfeatureQuery.xml";
	bool useOutputQueryCFFFile = false;
	string outputQueryCFFFileName = "outputNLPQuery.cff";
	bool useInputQueryXMLFile = false;
	string inputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryXMLFile = false;
	string outputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryCXLFile = false;
	string outputQueryCXLFileName = "semanticNetQuery.cxl";
	bool useOutputQueryLDRFile = false;
	string outputQueryLDRFileName = "semanticNetQuery.ldr";
	bool useOutputQueryPPMFile = false;
	string outputQueryPPMFileName = "semanticNetQuery.ppm";
	bool useOutputQuerySVGFile = false;
	string outputQuerySVGFileName = "semanticNetQuery.svg";
	#ifdef GIA_NEURAL_NETWORK
	bool ANNuseInputXMLFile = false;
	string ANNinputXMLFileName = string(NEURAL_NETWORK_VISUALISATION_BASE_FILE_NAME) + NEURAL_NETWORK_VISUALISATION_XML_FILE_EXTENSION;
	bool ANNuseOutputXMLFile = false;
	string ANNoutputXMLFileName = string(NEURAL_NETWORK_VISUALISATION_BASE_FILE_NAME) + NEURAL_NETWORK_VISUALISATION_XML_FILE_EXTENSION;
	bool ANNuseOutputLDRFile = false;
	string ANNoutputLDRFileName = string(NEURAL_NETWORK_VISUALISATION_BASE_FILE_NAME) + NEURAL_NETWORK_VISUALISATION_LDR_FILE_EXTENSION;
	bool ANNuseOutputSVGFile = false;
	string ANNoutputSVGFileName = string(NEURAL_NETWORK_VISUALISATION_BASE_FILE_NAME) + NEURAL_NETWORK_VISUALISATION_SVG_FILE_EXTENSION;
	bool ANNuseOutputPPMFile = false;
	string ANNoutputPPMFileName = string(NEURAL_NETWORK_VISUALISATION_BASE_FILE_NAME) + NEURAL_NETWORK_VISUALISATION_PPM_FILE_EXTENSION;
	bool ANNuseOutputPPMFileRaytraced = false;
	string ANNoutputPPMFileNameRaytraced = string(NEURAL_NETWORK_VISUALISATION_BASE_FILE_NAME) + NEURAL_NETWORK_VISUALISATION_PPM_RAYTRACED_FILE_EXTENSION;
	string ANNoutputTALFileName = string(NEURAL_NETWORK_VISUALISATION_BASE_FILE_NAME) + NEURAL_NETWORK_VISUALISATION_TAL_FILE_EXTENSION;
	bool ANNuseOutputAllFile = false;
	string ANNoutputAllFileName = NEURAL_NETWORK_VISUALISATION_BASE_FILE_NAME;
	bool ANNdrawOutput = false;
	bool ANNuseSprites = true;
	#endif
	#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
	bool useOutputTextAnswerPlainTXTFile = false;
	string outputTextAnswerPlainTXTFileName = "answer.txt";
	#endif
	#ifdef GIA_INPUT_FILE_LISTS
	bool inputFileList = false;
	#endif
	bool printOutputQuery = false;
	bool useInputQuery = false;
	#ifdef GIA_PREPROCESSOR
	bool useOutputQueryLRPTextPlainTXTFile = false;
	string outputQueryLRPTextPlainTXTFileName = "inputTextWithLRPQuery.txt";
	#endif
		
	//not currently used;
	if(!XMLrulesClassClass().parseNLCrulesXMLfile())
	{
		cout << "warning: NLCrules.xml file not detected" << endl;
		//exit(EXIT_ERROR);
	}

	if(!useInputTextPlainTXTFile && !useNLCinputFileList)
	{
		if(firstNLCfunctionInList == NULL)
		{
			cout << "NLC requires useInputTextPlainTXTFile (inlc) or useNLCinputFileList (inlcp) or (firstNLCfunctionInList != NULL)" << endl;
		}
	}

	int numberOfInputFilesInList = 0;
	vector<string> inputTextPlainTXTFileNameList;
	vector<string> functionNameList;

	#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
	if(useNLCinputFileList)
	{
		if(!SHAREDvarsClass().getLinesFromFile(NLCinputFileListName, &inputTextPlainTXTFileNameList, &numberOfInputFilesInList))
		{
			cout << "main{} error: !getLinesFromFile: " << inputTextPlainTXTfileName << endl;
		}
		#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE_SUPPORT_PREPROCESSOR
		else
		{
			if(useNLCpreprocessor)
			{
				//collapse all input list nlc text files into single input nlc text file
				string tempStr = "";
				SHAREDvarsClass().setCurrentDirectory(outputFolder);
				SHAREDvarsClass().writeStringToFile(inputTextPlainTXTfileName, &tempStr);	//creates a new empty inputTextPlainTXTfile.txt in the output folder
				SHAREDvarsClass().setCurrentDirectory(inputFolder);
				for(vector<string>::iterator inputTextPlainTXTFileNameListIter = inputTextPlainTXTFileNameList.begin(); inputTextPlainTXTFileNameListIter != inputTextPlainTXTFileNameList.end(); inputTextPlainTXTFileNameListIter++)
				{
					string inputTextPlainTXTfileNameSeparate = *inputTextPlainTXTFileNameListIter;
					string functionContents = SHAREDvarsClass().getFileContents(inputTextPlainTXTfileNameSeparate);
					SHAREDvarsClass().setCurrentDirectory(outputFolder);
					SHAREDvarsClass().appendStringToFile(inputTextPlainTXTfileName, &functionContents);
					SHAREDvarsClass().setCurrentDirectory(inputFolder);
				}
				SHAREDvarsClass().setCurrentDirectory(outputFolder);	//this is required such that NLC preprocessor can read the combined input file
				inputTextPlainTXTFileNameList.clear();	//this is required such that NLC preprocessor can refill inputTextPlainTXTFileNameList
				numberOfInputFilesInList = 1;		//this is required such that NLC preprocessor can refill inputTextPlainTXTFileNameList
			}
		}
		#endif
	}
	#endif

	#ifdef NLC_PREPROCESSOR
	//vector<string> inputTextPlainTXTFileNameList;
	bool preprocessorDetectedFunctions = false;
	string inputTextPlainTXTfileNameOrig = inputTextPlainTXTfileName;
	if(useNLCpreprocessor)
	{
		string outputPreprocessedTextForNLConlyPlainTXTFileName = inputTextPlainTXTfileName + NLC_PREPROCESSOR_PREPROCESSED_FILE_NAME_APPEND_TEXT;
		
		if(NLCpreprocessorClass().preprocessTextForNLCwrapper(inputTextPlainTXTfileName, &firstNLCfunctionInList, &preprocessorDetectedFunctions, &numberOfInputFilesInList, &inputTextPlainTXTFileNameList, outputPreprocessedTextForNLConlyPlainTXTFileName))
		{
			#ifdef NLC_INPUT_FUNCTION_LISTS_PREPROCESSOR
			if(preprocessorDetectedFunctions)
			{
				useNLCinputFileList = true;
			}
			else
			{
			#endif
				inputTextPlainTXTfileNameOrig = inputTextPlainTXTfileName;
				inputTextPlainTXTfileName = outputPreprocessedTextForNLConlyPlainTXTFileName;	//execute NLP on preprocessed file
			#ifdef NLC_INPUT_FUNCTION_LISTS_PREPROCESSOR
			}
			#endif
		}
		else
		{
			cerr << "main{} error: !preprocessTextForNLCwrapper{}" << endl;
			exit(EXIT_ERROR);
		}
	}
	else
	{
		firstNLCfunctionInList = new NLCfunction();	//is this required?
	}
	#endif


	vector<NLCclassDefinition*> classDefinitionList;
	vector<NLCcodeblock*> firstCodeBlockInTreeList;
	vector<vector<GIAentityNode*>*> entityNodesActiveListCompleteFunctions;
	vector<map<int, vector<GIAentityNode*>*>*> entityNodesActiveListSentencesFunctions;

	#ifdef NLC_ADVANCED_REFERENCING_SUPPORT_ALIASES_PREVENT_ADDING_AS_FUNCTION_ARGUMENT
	#ifdef NLC_ADVANCED_REFERENCING_SUPPORT_ALIASES_CROSS_FUNCTION_ALIASES
	NLCcodeBlockClassClass().initialiseFunctionAliasClassList();
	#endif
	#endif

	#ifdef NLC_LIBRARY_FUNCTION_LISTS_FOR_ARGUMENT_RECONCILIATION
	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS
	//added 1p3b - add functionDefinitionClassDefinition (with functionDependency) for every NLClibraryStandard and NLClibraryUser function (not NLClibraryBase functions; whose references are automatically generated by NLC)
	//parse list of NLClibraryStandardFunctionList.txt and NLClibraryUserFunctionList.txt
	vector<string> nlcLibraryFunctionList;
	int nlcLibraryFunctionListSizeTemp;
	#ifdef NLC_LIBRARY_STANDARD
	if(!SHAREDvarsClass().getLinesFromFile(NLC_LIBRARY_STANDARD_FUNCTION_LIST_FILE_NAME, &nlcLibraryFunctionList, &nlcLibraryFunctionListSizeTemp))
	{
		#ifndef NLC_LIBRARY_DISABLE_FUNCTIONS_LIST_WARNING
		cout << "main{} warning: " << NLC_LIBRARY_STANDARD_FUNCTION_LIST_FILE_NAME << " function arguments will not be reconciled" << endl;
		#endif
	}
	#endif
	#ifdef NLC_LIBRARY_USER
	if(!SHAREDvarsClass().getLinesFromFile(NLC_LIBRARY_USER_FUNCTION_LIST_FILE_NAME, &nlcLibraryFunctionList, &nlcLibraryFunctionListSizeTemp))
	{
		#ifndef NLC_LIBRARY_DISABLE_FUNCTIONS_LIST_WARNING
		cout << "main{} warning: " << NLC_LIBRARY_USER_FUNCTION_LIST_FILE_NAME << " function arguments will not be reconciled" << endl;
		#endif
	}
	#endif
	for(vector<string>::iterator nlcLibraryFunctionListIter = nlcLibraryFunctionList.begin(); nlcLibraryFunctionListIter != nlcLibraryFunctionList.end(); nlcLibraryFunctionListIter++)
	{
		string nlcLibraryFunctionName = (*nlcLibraryFunctionListIter);
		if(NLCpreprocessorClass().detectFunctionHeader(&nlcLibraryFunctionName))
		{
			string NLCfunctionName = NLCpreprocessorClass().getFunctionNameFromFunctionHeader(&nlcLibraryFunctionName);
			NLCtranslatorClass().createFunctionDefinitionClassDefinition(&classDefinitionList, NLCfunctionName, FUNCTION_INDEX_LIBRARY_FUNCTION, true);
		}
		else
		{
			cout << "main{} error: !detectFunctionHeader: nlcLibraryFunctionName = " << nlcLibraryFunctionName << endl;
		}
	}
	#endif
	#endif

	//#ifdef NLC_PREPROCESSOR
	NLCfunction* currentNLCfunctionInList = firstNLCfunctionInList;
	//#endif
	for(int functionDefinitionIndex=0; functionDefinitionIndex<numberOfInputFilesInList; functionDefinitionIndex++)
	{		
		NLCcodeblock* firstCodeBlockInTree = new NLCcodeblock();
		firstCodeBlockInTreeList.push_back(firstCodeBlockInTree);

		GIAtranslatorVariablesClass* translatorVariables = new GIAtranslatorVariablesClass();
		translatorVariables->isQuery = false;
		#ifdef NLC_NLCI
		if(numberOfInputFilesInList == 1)
		{
			//if a single function (ie sentence list) has been passed to NLC by NLCI for debugging, then store entities for access by NLCI
			translatorVariables->entityNodesActiveListComplete = translatorVariablesTemplate->entityNodesActiveListComplete;
			translatorVariables->entityNodesActiveListNetworkIndexes = translatorVariablesTemplate->entityNodesActiveListNetworkIndexes;
			translatorVariables->timeConditionNodesActiveList = translatorVariablesTemplate->timeConditionNodesActiveList;
			translatorVariables->entityNodesActiveListSentences = translatorVariablesTemplate->entityNodesActiveListSentences;
		}
		else
		{
			//if a function list has been passed to NLC by NLCI for compilation of nlc project to C++, then do not store entities for access by NLCI
			translatorVariables->entityNodesActiveListComplete = new vector<GIAentityNode*>;
			translatorVariables->entityNodesActiveListNetworkIndexes = new unordered_map<string, GIAentityNode*>;
			translatorVariables->timeConditionNodesActiveList = new unordered_map<int64_t, GIAtimeConditionNode*>;
			translatorVariables->entityNodesActiveListSentences = new map<int, vector<GIAentityNode*>*>;
		}
		#else
		translatorVariables->entityNodesActiveListComplete = new vector<GIAentityNode*>;
		translatorVariables->entityNodesActiveListNetworkIndexes = new unordered_map<string, GIAentityNode*>;
		translatorVariables->timeConditionNodesActiveList = new unordered_map<int64_t, GIAtimeConditionNode*>;
		translatorVariables->entityNodesActiveListSentences = new map<int, vector<GIAentityNode*>*>;
		#endif
		if(useNLCpreprocessor)
		{
			translatorVariables->firstGIApreprocessorSentenceInList = currentNLCfunctionInList->firstGIApreprocessorSentenceInList;	
		}
		else
		{
			translatorVariables->firstGIApreprocessorSentenceInList = translatorVariablesTemplate->firstGIApreprocessorSentenceInList;	//ie most likely NULL (unless the higher level application is executing NLC without useNLCpreprocessor)
		}
		
		entityNodesActiveListCompleteFunctions.push_back(translatorVariables->entityNodesActiveListComplete);
		entityNodesActiveListSentencesFunctions.push_back(translatorVariables->entityNodesActiveListSentences);
		translatorVariables->NLPfeatureParser = translatorVariablesTemplate->NLPfeatureParser;
		translatorVariables->NLPdependencyRelationsParser = translatorVariablesTemplate->NLPdependencyRelationsParser;
		translatorVariables->NLPrelexCompatibilityMode = translatorVariablesTemplate->NLPrelexCompatibilityMode;
		translatorVariables->NLPassumePreCollapsedStanfordRelations = translatorVariablesTemplate->NLPassumePreCollapsedStanfordRelations;
		#ifdef GIA_NLP_CLIENT_SERVER
		translatorVariables->NLPclient = translatorVariablesTemplate->NLPclient;
		#endif
		SHAREDvarsClass().copyStringArray(translatorVariablesTemplate->NLPexeFolderArray, translatorVariables->NLPexeFolderArray, GIA_NLP_PARSER_NUMBER_OF_TYPES);

		GIAtranslatorVariablesClass* translatorVariablesQuery = NULL;	//not used by NLC;
		
		#ifdef NLC_INPUT_FUNCTION_LISTS
		if(useNLCinputFileList)
		{
			//this will be the only case executed if useNLCpreprocessor
			inputTextPlainTXTfileName = inputTextPlainTXTFileNameList.at(functionDefinitionIndex);
			useInputTextPlainTXTFile = true;	//this is required for GIA
		}
		#endif

		SHAREDvarsClass().setCurrentDirectory(inputFolder);	//NB executeGIA must be executed with current directory set to the original inputFolder (such that GIArules.xml can be read)
		string inputFolderOrig = inputFolder;
		#ifdef NLC_PREPROCESSOR
		if(useNLCpreprocessor)
		{
			if(outputFolder != inputFolder)
			{
				//this is required such that GIA uses the output folder as its input folder (ie inputFolder), considering NLP has already written its output to this folder
				SHAREDvars.copyFiles(inputFolder, NLC_RULES_XML_FILE_NAME, outputFolder, NLC_RULES_XML_FILE_NAME);
				SHAREDvars.copyFiles(inputFolder, GIA_RULES_XML_FILE_NAME, outputFolder, GIA_RULES_XML_FILE_NAME);
				SHAREDvars.copyFiles(inputFolder, GIA_SYN_REL_TRANSLATOR_RULES_XML_FILE_NAME, outputFolder, GIA_SYN_REL_TRANSLATOR_RULES_XML_FILE_NAME);
				SHAREDvars.copyFiles(inputFolder, GIA_TXT_REL_TRANSLATOR_RULES_XML_FILE_NAME, outputFolder, GIA_TXT_REL_TRANSLATOR_RULES_XML_FILE_NAME);
				inputFolder = outputFolder;
			}
		}
		#endif

		NLCtranslatorCodeBlocksOperationsClass().setFirstNLCsentenceInList(currentNLCfunctionInList->firstNLCsentenceInFunction);
		#ifdef GIA_NLC_INTEGRATION
		GIAtranslatorOperationsClass().setFirstNLCsentenceInListGIA(currentNLCfunctionInList->firstNLCsentenceInFunction);
		#endif

		#ifdef USE_CS_WORKAROUND
		GIAmainClass().executeGIA2();
		#endif
		GIAmainClass().executeGIA(

			translatorVariables,
			translatorVariablesQuery,

			inputFolder,
			outputFolder,

			useInputTextPlainTXTFile,
			inputTextPlainTXTfileName,
			useInputTextNLPrelationXMLFile,
			inputTextNLPrelationXMLfileName,
			useInputTextNLPfeatureXMLFile,
			inputTextNLPfeatureXMLfileName,
			useInputTextXMLFile,
			inputTextXMLFileName,
			
			useOutputTextCFFFile,
			outputTextCFFFileName,
			useOutputTextXMLFile,
			outputTextXMLFileName,
			useOutputTextCXLFile,
			outputTextCXLFileName,
			useOutputTextLDRFile,
			outputTextLDRFileName,
			useOutputTextPPMFile,
			outputTextPPMFileName,
			useOutputTextSVGFile,
			outputTextSVGFileName,
			useInputQueryPlainTXTFile,
			inputQueryPlainTXTFileName,
			useInputQueryNLPrelationXMLFile,
			inputQueryNLPrelationXMLFileName,
			useInputQueryNLPfeatureXMLFile,
			inputQueryNLPfeatureXMLFileName,
			useOutputQueryCFFFile,
			outputQueryCFFFileName,
			useInputQueryXMLFile,
			inputQueryXMLFileName,
			useOutputQueryXMLFile,
			outputQueryXMLFileName,
			useOutputQueryCXLFile,
			outputQueryCXLFileName,
			useOutputQueryLDRFile,
			outputQueryLDRFileName,
			useOutputQueryPPMFile,
			outputQueryPPMFileName,
			useOutputQuerySVGFile,
			outputQuerySVGFileName,
			useOutputTextAllFile,
			outputTextAllFileName,
			
			#ifdef GIA_NEURAL_NETWORK
			ANNuseInputXMLFile,
			ANNinputXMLFileName,	
			ANNuseOutputXMLFile,
			ANNoutputXMLFileName,
			ANNuseOutputLDRFile,
			ANNoutputLDRFileName,
			ANNuseOutputSVGFile,
			ANNoutputSVGFileName,
			ANNuseOutputPPMFile,
			ANNoutputPPMFileName,
			ANNuseOutputPPMFileRaytraced,
			ANNoutputPPMFileNameRaytraced,				
			ANNuseOutputAllFile,
			ANNoutputAllFileName,
			ANNuseSprites,
			#endif
		
			#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
			useOutputTextAnswerPlainTXTFile,
			outputTextAnswerPlainTXTFileName,
			#endif

			#ifdef GIA_INPUT_FILE_LISTS
			inputFileList,
			#endif
			printOutput,
			printOutputQuery,
			displayInOpenGLAndOutputScreenshot,

			rasterImageWidth,
			rasterImageHeight,

			useInputQuery,

			#ifdef GIA_DATABASE
			readFromDatabase,
			writeToDatabase,
			useDatabase,
			KBdatabaseFolderName,
			#endif
			#ifdef GIA_SEM_REL_TRANSLATOR
			semanticParserDatabaseFolderName,
			#endif
			#ifdef GIA_PREPROCESSOR_POS_TAGGER_DATABASE_PERSISTENT
			POStaggerDatabaseFolderName,
			#endif
		
			#ifdef GIA_PREPROCESSOR
			useLRP,
			useOutputLRPTextPlainTXTFile,
			outputLRPTextPlainTXTFileName,
			useOutputQueryLRPTextPlainTXTFile,
			outputQueryLRPTextPlainTXTFileName,
			lrpDataFolderName,
			#endif

			#ifdef USE_WORDNET
			synonymnDetectionStatus
			#endif
		);

		SHAREDvarsClass().setCurrentDirectory(outputFolder);	//redundant	//NB executeGIA will change the current directory to the outputFolder, meaning NLC does not have to set the current directory to the outputFolder after executing GIA
		inputFolder = inputFolderOrig;

		string NLCfunctionName = "";
		if(useNLCinputFileList)
		{
			NLCfunctionName = currentNLCfunctionInList->NLCfunctionName;
			//cout << "NLCfunctionName = " << NLCfunctionName << endl;
		}
		else
		{
			if(currentNLCfunctionInList->NLCfunctionName != "")
			{
				NLCfunctionName = currentNLCfunctionInList->NLCfunctionName;
			}
			else
			{
				#ifdef NLC_PREDEFINED_FUNCTION_NAME_FOR_NATURAL_LANGUAGE_CODE_WITHOUT_FUNCTION_SPECIFIED
				NLCfunctionName = NLC_PREDEFINED_FUNCTION_NAME_FOR_NATURAL_LANGUAGE_CODE_WITHOUT_FUNCTION_SPECIFIED_NAME;
				#else
				if(useInputTextPlainTXTFile)
				{
					#ifdef NLC_PREPROCESSOR
					if(useNLCpreprocessor)
					{
						NLCfunctionName = inputTextPlainTXTfileNameOrig;	//NLC 1i2c - do not add "afterPreprocessedforNLConly" to function name
					}
					else
					{
					#endif
						NLCfunctionName = inputTextPlainTXTfileName;
					#ifdef NLC_PREPROCESSOR
					}
					#endif
				}
				else
				{
					cout << "error: NLC requires useInputTextPlainTXTFile" << endl;
				}

				#ifdef NLC_STRICT_MODE_FAVOUR_COMPILATION_RATHER_THAN_DESIGN_USE_MAIN_ENTRY_POINT
				NLCfunctionName = progLangMainEntryPointFunctionName[progLang];
				#else
				NLCfunctionName = NLCmainClass().removeFileNameExtensions(NLCfunctionName);
				#endif

				#endif
			}
		}
		
		#ifdef NLC_INPUT_FUNCTION_LISTS
		functionNameList.push_back(NLCfunctionName);
		#endif

		//generate class definition function declaration for new function definition (creates both functionDependency object and classDefinition object)
		NLCtranslatorClass().createFunctionDefinitionClassDefinition(&classDefinitionList, NLCfunctionName, functionDefinitionIndex, false);

		NLCtranslatorClass().translateNetwork(firstCodeBlockInTree, &classDefinitionList, translatorVariables->entityNodesActiveListComplete, translatorVariables->entityNodesActiveListSentences, translatorVariables->maxNumberSentences, NLCfunctionName, currentNLCfunctionInList, useNLCpreprocessor);

		#ifdef NLC_PREPROCESSOR
		if(useNLCpreprocessor)
		{
			currentNLCfunctionInList = currentNLCfunctionInList->next;
		}
		#endif
	}


	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS
	if(!NLCmainClass().generateClassDefinitionFunctionDeclarationsAndReconcileArguments(numberOfInputFilesInList, &classDefinitionList, &entityNodesActiveListCompleteFunctions, &firstCodeBlockInTreeList))
	{
		result = false;
	}
	#endif

	#ifdef NLC_PREVENT_INHERITANCE_DOUBLE_DECLARATIONS_OF_CLASS_LIST_VARIABLES
	NLCtranslatorClassDefinitionsClass().preventDoubleDeclarationsOfClassDefinitionVariablesInHeirachy(&classDefinitionList);	//moved 1q9a
	#endif

	string code = "";

	#ifdef NLC_API
	vector<string> APIclassList;
	int numberOfFilesInAPIclassList = 0;
	if(NLCapi)
	{
		#ifdef NLC_API_SEPARATE_FILE_FOR_WRAPPER_FUNCTIONS
		vector<NLCclassDefinition*>* classDefinitionListAPI = &classDefinitionList;
		#else
		vector<NLCclassDefinition*>* classDefinitionListAPI = new vector<NLCclassDefinition*>;
		#endif
		if(!SHAREDvarsClass().getLinesFromFile(APIclassListFileName, &APIclassList, &numberOfFilesInAPIclassList))
		{
			cout << "main{} error: !getLinesFromFile: " << APIclassListFileName << endl;
		}
		for(vector<string>::iterator iter = APIclassList.begin(); iter != APIclassList.end(); iter++)
		{
			string APIclassName = *iter;
			if(!NLCapiClass().parseDoxygenClassXMLfile(APIclassName, APIsourceFolder, classDefinitionListAPI, progLang))
			{
				cout << "main{} error: !NLCapiClass().parseDoxygenClassXMLfile(: " << APIsourceFolder + "..." + APIclassName + "..." << endl;
			}
		}
		#ifdef NLC_API_SEPARATE_FILE_FOR_WRAPPER_FUNCTIONS
		#else
		if(NLCprintClassDefinitionsClass().printClassDefinitions(classDefinitionListAPI, progLang, &code, true, firstNLCfunctionInList))
		{

		}
		#endif
	}
	#endif

	#ifdef NLC_INPUT_FUNCTION_LISTS
	#ifndef NLC_NONOO_DISABLE_CLASS_HEIRACHY
	if(!NLCprintClassDefinitionsClass().printClassDefinitions(&classDefinitionList, progLang, &code, false, firstNLCfunctionInList))
	{
		result = false;
	}
	#endif
	#endif

	#ifndef NLC_LIBRARY
	//create predefined NLC functions
	NLCcodeblock* currentCodeBlockInTree = firstCodeBlockInTreeList.at(numberOfInputFilesInList-1);	//get firstCodeBlockInTreeList in last function
	NLCmainClass().printPredefinedNLCfunctions(currentCodeBlockInTree);
	#endif

	for(int functionDefinitionIndex=0; functionDefinitionIndex<numberOfInputFilesInList; functionDefinitionIndex++)
	{
		NLCcodeblock* firstCodeBlockInTree = firstCodeBlockInTreeList.at(functionDefinitionIndex);
		int level = 0;
		#ifdef NLC_INPUT_FUNCTION_LISTS
		if(!NLCprintCodeBlocksClass().printCodeBlocks(firstCodeBlockInTree, &classDefinitionList, progLang, &code, level))
		{
			result = false;
		}
		#else
		if(!NLCprintClass().printCode(firstCodeBlockInTree, &classDefinitionList, progLang, &code, firstNLCfunctionInList))
		{
			result = false;
		}
		#endif
		
	}
	
	#ifdef USE_NLCI
	translatorVariablesTemplate->nlcGeneratedCode = code;
	#else
	#ifndef NLC_LIBRARY_GENERATE_INDIVIDUAL_FILES_ADD_CLASS_FUNCTIONS_TO_CLASS_DEFINITIONS
	cout << "code = \n" << code << endl;
	#endif	
	#endif
	
	return result;
}

string NLCmainClass::removeFileNameExtensions(string NLCfunctionName)
{
	string NLCfunctionNameCleaned = NLCfunctionName;
	int indexOfFirstFileExtension = NLCfunctionName.find(".");
	if(indexOfFirstFileExtension != CPP_STRING_FIND_RESULT_FAIL_VALUE)
	{
		NLCfunctionNameCleaned = NLCfunctionName.substr(0, indexOfFirstFileExtension);
	}
	return NLCfunctionNameCleaned;
}

string NLCmainClass::removeNLCfileNameExtension(string NLCfunctionName)
{
	string NLCfunctionNameCleaned = NLCfunctionName;
	int indexOfFirstFileExtension = NLCfunctionName.find(NLC_NATURAL_LANGUAGE_CODE_FILE_NAME_EXTENSION);
	if(indexOfFirstFileExtension != CPP_STRING_FIND_RESULT_FAIL_VALUE)
	{
		NLCfunctionNameCleaned = NLCfunctionName.substr(0, indexOfFirstFileExtension);
	}
	#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE_ENFORCE_NLC_FILE_EXTENSIONS
	else
	{
		cerr << "removeNLCfileNameExtension{} error: .nlc (natural language code) file extension expected, NLCfunctionName = " << NLCfunctionName << endl;
		exit(EXIT_ERROR);
	}
	#endif
	return NLCfunctionNameCleaned;
}





#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS
bool NLCmainClass::generateClassDefinitionFunctionDeclarationsAndReconcileArguments(const int numberOfInputFilesInList, vector<NLCclassDefinition*>* classDefinitionList, vector<vector<GIAentityNode*>*>* entityNodesActiveListCompleteFunctions, vector<NLCcodeblock*>* firstCodeBlockInTreeList)
{
	bool result = true;

	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE
	//added 1k13g - generate class definition function declarations for all function execution references (generateClassHeirarchyFunctions has been separated from generateClassHeirarchy since non-exact function reconciliation can only occur once class definition heirachy has been established)
	for(int functionDefinitionIndex=0; functionDefinitionIndex<numberOfInputFilesInList; functionDefinitionIndex++)
	{
		NLCclassDefinition* functionDefinitionClassDefinition = NULL;
		if(NLCclassDefinitionClass.findFunctionDependencyClassDefinitionInListByIndex(classDefinitionList, functionDefinitionIndex, &functionDefinitionClassDefinition))
		{
			vector<GIAentityNode*>* entityNodesActiveListComplete = entityNodesActiveListCompleteFunctions->at(functionDefinitionIndex);

			//NLC translator Part 2b.
			if(!NLCtranslatorClassDefinitions.generateClassHeirarchyFunctions(classDefinitionList, entityNodesActiveListComplete, functionDefinitionClassDefinition))
			{
				result = false;
			}
		}
	}
	#endif



	#ifdef NLC_INPUT_FUNCTION_LISTS
	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_ACTIVE
	bool stillUnreconciledFunctionDeclarationArguments = true;
	while(stillUnreconciledFunctionDeclarationArguments)
	{
		stillUnreconciledFunctionDeclarationArguments = false;
		for(vector<NLCclassDefinition*>::iterator classDefinitionListIter = classDefinitionList->begin(); classDefinitionListIter != classDefinitionList->end(); classDefinitionListIter++)
		{
			NLCclassDefinition* classDefinition = *classDefinitionListIter;
			if(classDefinition->functionDependency != NULL)
			{
				NLCclassDefinitionFunctionDependency* functionDefinitionFunctionDependency = classDefinition->functionDependency;
				#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
				if(functionDefinitionFunctionDependency->functionDefinitionListIndex != FUNCTION_INDEX_LIBRARY_FUNCTION)	//redundant check (NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES: functionDependencies are now only defined for functionDefinition classDefinitions)
				#else
				if(functionDefinitionFunctionDependency->functionDefinitionListIndex != INT_DEFAULT_VALUE)	//redundant check (NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES: functionDependencies are now only defined for functionDefinition classDefinitions)
				#endif
				{
					if(!(functionDefinitionFunctionDependency->isReferenceElseFunctionDefinition))	//redundant check (checking functionDefinitionListIndex already)
					{
						if(!(functionDefinitionFunctionDependency->reconciledFunctionDeclarationArguments))
						{
							bool reconciledChildFunctionDeclarationArguments = true;
							for(vector<NLCclassDefinition*>::iterator classDefinitionListIter2 = classDefinition->functionDependencyList.begin(); classDefinitionListIter2 != classDefinition->functionDependencyList.end(); classDefinitionListIter2++)
							{
								NLCclassDefinitionFunctionDependency* functionDefinitionFunctionDependencyChild = (*classDefinitionListIter2)->functionDependency;
								#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
								if(functionDefinitionFunctionDependencyChild->functionDefinitionListIndex != FUNCTION_INDEX_LIBRARY_FUNCTION)
								#else
								if(functionDefinitionFunctionDependencyChild->functionDefinitionListIndex != INT_DEFAULT_VALUE)
								#endif
								{
									if(!(functionDefinitionFunctionDependencyChild->isReferenceElseFunctionDefinition))	//redundant check (checking functionDefinitionListIndex already)
									{
										if(!(functionDefinitionFunctionDependencyChild->reconciledFunctionDeclarationArguments))
										{
											reconciledChildFunctionDeclarationArguments = false;
										}
									}
									else
									{
										cerr << "NLCmain error: functionDefinitionFunctionDependencyChild->functionDefinitionListIndex != INT_DEFAULT_VALUE && functionDefinitionFunctionDependencyChild->isReferenceElseFunctionDefinition" << endl;
										exit(EXIT_ERROR);
									}
								}
								#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
								#ifndef NLC_LIBRARY
								else
								{
									cerr << "NLCmain error: functionDefinitionFunctionDependencyChild->functionDefinitionListIndex == INT_DEFAULT_VALUE. FunctionDependencies are only defined for functionDefinition classDefinitions" << endl;
									exit(EXIT_ERROR);
								}
								#endif
								#endif
							}
							if(reconciledChildFunctionDeclarationArguments)
							{
								//updates all classDefinition functionList function declaration arguments corresponding to a single defined function (functionDefinitionFunctionDependency->functionDefinitionListIndex)

								NLCcodeblock* firstCodeBlockInTree = firstCodeBlockInTreeList->at(functionDefinitionFunctionDependency->functionDefinitionListIndex);

								NLCtranslator.reconcileFunctionDefinitionClassDefinitionArgumentsBasedOnImplicitlyDeclaredVariablesInCurrentFunctionDefinition(firstCodeBlockInTree, classDefinitionList, classDefinition);

								functionDefinitionFunctionDependency->reconciledFunctionDeclarationArguments = true;
							}
							stillUnreconciledFunctionDeclarationArguments = true;
						}
					}
					else
					{
						cerr << "NLCmain error: functionDefinitionFunctionDependency->functionDefinitionListIndex != INT_DEFAULT_VALUE && functionDefinitionFunctionDependency->isReferenceElseFunctionDefinition" << endl;
						exit(EXIT_ERROR);
					}
				}
				#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
				#ifndef NLC_LIBRARY
				else
				{
					cerr << "NLCmain error: functionDefinitionFunctionDependency->functionDefinitionListIndex == INT_DEFAULT_VALUE. FunctionDependencies are only defined for functionDefinition classDefinitions" << endl;
					exit(EXIT_ERROR);
				}
				#endif
				#endif
			}
		}
	}
	#else
	for(int functionDefinitionIndex=0; functionDefinitionIndex<numberOfInputFilesInList; functionDefinitionIndex++)
	{
		NLCclassDefinition* functionDefinitionClassDefinition = NULL;
		if(NLCclassDefinitionClass.findFunctionDependencyClassDefinitionInListByIndex(&functionDependencyList, functionDefinitionIndex, &functionDefinitionClassDefinition))
		{
			if(functionDefinitionClassDefinition->functionDependency != NULL)
			{
				NLCclassDefinitionFunctionDependency* functionDefinitionFunctionDependency = functionDefinitionClassDefinition->functionDependency;
				if(functionDefinitionFunctionDependency->functionDefinitionListIndex != INT_DEFAULT_VALUE)
				{
					//updates all classDefinition functionList function declaration arguments corresponding to a single defined function (functionDefinitionFunctionDependency->functionDefinitionListIndex)

					NLCcodeblock* firstCodeBlockInTree = firstCodeBlockInTreeList->at(functionDefinitionFunctionDependency->functionDefinitionListIndex);

					isLibraryFunction = false;

					NLCtranslator.reconcileFunctionDefinitionClassDefinitionArgumentsBasedOnImplicitlyDeclaredVariablesInCurrentFunctionDefinition(firstCodeBlockInTree, &classDefinitionList, functionDefinitionClassDefinition);

					//update variable names in function to 'this' if necessary based on formalFunctionArgumentCorrespondsToActionSubjectUseThisAlias
				}
				#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
				#ifndef NLC_LIBRARY
				else
				{
					cerr << "NLCmain error: functionDefinitionFunctionDependency->functionDefinitionListIndex == INT_DEFAULT_VALUE. FunctionDependencies are only defined for functionDefinition classDefinitions" << endl;
					exit(EXIT_ERROR);
				}
				#endif
				#endif

			}
		}
	}
	#endif
	#endif

	return result;
}
#endif


#ifndef NLC_LIBRARY
void NLCmainClass::printPredefinedNLCfunctions(NLCcodeblock* currentCodeBlockInTree);
{
	//create predefined NLC functions
	currentCodeBlockInTree = NLCcodeBlockClass.getLastCodeBlockInLevel(currentCodeBlockInTree);
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockAddEntityToCategoryListCheckLastSentenceReferencedPluralNewFunction(currentCodeBlockInTree);
	#ifdef NLC_ADVANCED_REFERENCING
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockAddEntityToCategoryListCheckLastSentenceReferencedSingularNewFunction(currentCodeBlockInTree);
	#ifdef NLC_ADVANCED_REFERENCING_MONITOR_CONTEXT
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksAddEntityToContextLevelListNewFunction(currentCodeBlockInTree);
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksClearContextListNewFunction(currentCodeBlockInTree);
	#endif
	#endif
	#ifndef NLC_NONOO
	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksCastVectorNewFunction(currentCodeBlockInTree);
	#endif
	#endif
	#ifdef NLC_ADVANCED_REFERENCING_SUPPORT_ALIASES
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksFindAliasAndAddToCategoryListNewFunction(currentCodeBlockInTree);
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksFindAliasNewFunction(currentCodeBlockInTree);
	#endif
	#ifdef NLC_REDEFINITIONS
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockCheckParentClassNameNewFunction(currentCodeBlockInTree);
	#endif
	#ifdef NLC_NON_LIBRARY_FUNCTIONS_EXTENDED
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockAddPropertyNewFunction(currentCodeBlockInTree);
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockAddConditionNewFunction(currentCodeBlockInTree);
	#endif
	#ifdef NLC_TRANSLATOR_TEST_DEFINITE_ENTITY_EXISTENCE
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeVerifyDefiniteReferenceExistenceNewFunction(currentCodeBlockInTree);	
	#endif
}
#endif


