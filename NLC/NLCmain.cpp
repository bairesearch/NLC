/*******************************************************************************
 *
 * This file is part of BAIPROJECT.
 *
 * BAIPROJECT is licensed under the GNU Affero General Public License
 * version 3, as published by the Free Software Foundation. The use of
 * intermediary programs or interfaces including file i/o is considered
 * remote network interaction. This does not imply such arrangements
 * do not constitute derivative works.
 *
 * BAIPROJECT is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License version 3 for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU Affero General Public License
 * version 3 along with BAIPROJECT.  If not, see <http://www.gnu.org/licenses/>
 * for a copy of the AGPLv3 License.
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: NLCmain.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2017 Baxter AI (baxterai.com)
 * Project: Natural Language Compiler (Programming Interface)
 * Project Version: 2b1a 19-May-2017
 * Requirements: requires text parsed by BAI General Intelligence Algorithm (GIA)
 *
 *******************************************************************************/


#include "NLCmain.hpp"

static char errmessage[] = "Usage:  NLC.exe [options]\n\n\twhere options are any of the following\n"
"\n\t-itxt [string]     : plain text .txt input filename to be parsed by the NLP parser (def: inputText.txt)"
"\n\t-ionlprel [string] : NLP dependency relation parser .xml intermediary input/output filename (def: inputNLPrelation.xml)"
"\n\t-ionlptag [string] : NLP feature tag parser .xml intermediary input/output filename (def: inputNLPfeature.xml)"
"\n\t-ixml [string]     : semantic network definition .xml input filename (def: semanticNet.xml)"
#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
"\n\t-ilist		: all input files (itxt, ionlprel, ionlptag, ixml) will be treated as file lists (new line delimited) referencing NLC function names ([functionSubject#]functionName)[+functionObject])"
#endif
#ifdef NLC_PREPROCESSOR
"\n\t-ipreprocess	: itxt input file will be preprocessed, supporting condition block indentation (eg if the ball is red\\n\\tthe stars are bright\\n\\tthe cat is happy) and multiple functions (delimited by 'function [functionSubject#]functionName)[+functionObject]'"
#endif
#ifdef NLC_API
"\n\t-api                       : expose third party API (wrap with NLC code) using doxygen xml output"
"\n\t-apisourcefolder [string]  : location of third party API source code (def: /home/systemusername/source/doxygen)"
"\n\t-apiclasslist [string]   	: third party API class list (def: apiClassList.txt)"
#endif
"\n\t-oxml [string]     : semantic network definition .xml output filename (def: semanticNet.xml)"
"\n\t-ocxl [string]     : semantic network display .cxl vector graphics output filename (def: semanticNet.cxl)"
"\n\t-osvg [string]     : semantic network display .svg 2D vector graphics output filename (def: semanticNet.svg)"
"\n\t-oldr [string]     : semantic network display .ldr 3D vector graphics output filename (def: semanticNet.ldr)"
"\n\t-oppm [string]     : semantic network display .ppm raster graphics output filename (def: semanticNet.ppm)"
"\n\t-ocff [string]     : NLP parser generated .cff output filename (def: outputNLP.cff)"
"\n\t-oall [string]     : semantic network display xml/.svg/.ldr/.ppm default generic output filename (def: semanticNet)"
"\n\t-notshow           : do not display output in opengl"
"\n\t-width [int]       : raster graphics width in pixels (def: 640)"
"\n\t-height [int]      : raster graphics height in pixels (def: 480)"
"\n\t-nlprelation [int] : NLP dependency relation parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP, 2 - Stanford Parser [def])"
"\n\t-nlpfeature [int]  : NLP feature parser to be executed by GIA (0 - Relex, 1 - Stanford Core NLP [def], 2 - Stanford Parser (ie, none))"
"\n\t-nlpcompmode [int] : sets Relex into Stanford compatibility mode (0 - off [def], 1 - (assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode, 2 - assumes Relex dependency relations were generated by GIA in cff) [UNTESTED]"
#ifdef GIA_DATABASE
"\n\t-dbread            : read from database (GIA knowledge base) [improves referencing capacity]"
"\n\t-dbwrite           : write to database (GIA knowledge base) [saves knowledge]"
"\n\t-dbfolder          : database base folder path (def: /home/systemusername/source/GIAKBdatabase)"
#endif
#ifdef GIA_SEMANTIC_PARSER
"\n\t-dbsemanticparserfolder    : direct semantic parser (corpus or optimised) database base folder path (def: /home/systemusername/source/GIAsemanticparserdatabase)"
#endif
#ifdef GIA_PREPROCESSOR
"\n\t-lrp                               : language reduction preprocessor"
"\n\t-olrptxt [string]                  : plain text .txt output filename with GIA language reduction preprocessor applied (def: inputTextWithLRP.txt)"
"\n\t-lrpfolder                         : folder of LRP data files (list of multiword verbs, multiword prepositions etc) (def: same as exe)"
#endif
#ifdef USE_WORDNET
"\n\t-syndet                            : wordnet synonymn detection (0 - off, 1 - during queries only, 2 - during referencing and queries [def])"
#endif
"\n"
"\n\t-inputfolder [string]              : input directory name for input files (def: same as exe)"
"\n\t-nlprelexfolder [string]           : directory name for Relex (def: same as exe)"
"\n\t-nlpstanfordcorenlpfolder [string] : directory name for Stanford Parser (def: same as nlprelexefolder)"
"\n\t-nlpstanfordparserfolder [string]  : directory name for Stanford CoreNLP (def: same as nlprelexefolder)"
#ifdef GIA_NLP_CLIENT_SERVER
"\n\t-nlpclient                         : execute NLP as client (requires server to be already started)"
#endif
"\n\t-outputfolder [string]             : output directory name for temporary and output files (def: same as exe)"
"\n"
"\n\n\t-version         : print version"
"\n\n\tThis program performs NLC (Natural Language Compiler) operations - generates computer code (eg C++) from natural language statements (it currently requires to be compiled with GIA source code).\n\n";


int main(const int argc, const char** argv)
{
	int progLang = NLC_PROGRAMMING_LANGUAGE_DEFAULT;
	NLCprintDefsClass().setProgLang(progLang);

	//print execution time
	struct tm* current;
	time_t now;
	time(&now);
	current = localtime(&now);
	char timeAndDateString[100];
	sprintf(timeAndDateString, "%i:%i:%i %.2i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, (current->tm_mon+1), (current->tm_year + TM_STRUCT_YEAR_OFFSET));
	cout << "NLC execution time: " << timeAndDateString << " (start)" << endl;

	bool result = true;

	int NLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_TEXT_DEFAULT;
	int NLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_TEXT_DEFAULT;
	bool NLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool NLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff
	#ifdef GIA_NLP_CLIENT_SERVER
	bool NLPclient = false;
	#endif
	
	int queryNLPfeatureParser = GIA_NLP_FEATURE_PARSER_FOR_INPUT_QUERY_DEFAULT;
	int queryNLPdependencyRelationsParser = GIA_NLP_RELATIONS_PARSER_FOR_INPUT_QUERY_DEFAULT;
	bool queryNLPrelexCompatibilityMode = false;			//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode
	bool queryNLPassumePreCollapsedStanfordRelations = false;	//(assumes) Relex dependency relations are(/were) generated by Relex parser in Stanford compatibility mode / assumes Relex dependency relations were generated by GIA in cff

	string NLPexeFolderArray[GIA_NLP_PARSER_NUMBER_OF_TYPES];

	bool useInputTextPlainTXTFile = false;
	string inputTextPlainTXTfileName = "inputText.txt";

	bool useInputTextNLPrelationXMLFile = false;
	string inputTextNLPrelationXMLfileName = "inputNLPrelation.xml";
	bool useInputTextNLPfeatureXMLFile = false;
	string inputTextNLPfeatureXMLfileName = "inputNLPfeature.xml";
	bool useOutputTextCFFFile = false;
	string outputTextCFFFileName = "outputNLP.cff";
	bool useInputTextXMLFile = false;
	string inputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextXMLFile = false;
	string outputTextXMLFileName = "semanticNet.xml";
	bool useOutputTextCXLFile = false;
	string outputTextCXLFileName = "semanticNet.cxl";
	bool useOutputTextLDRFile = false;
	string outputTextLDRFileName = "semanticNet.ldr";
	bool useOutputTextPPMFile = false;
	string outputTextPPMFileName = "semanticNet.ppm";
	bool useOutputTextSVGFile = false;
	string outputTextSVGFileName = "semanticNet.svg";
	bool useInputQueryPlainTXTFile = false;
	string inputQueryPlainTXTFileName = "inputTextQuery.txt";
	bool useInputQueryNLPrelationXMLFile = false;
	string inputQueryNLPrelationXMLFileName = "inputNLPrelationQuery.xml";
	bool useInputQueryNLPfeatureXMLFile = false;
	string inputQueryNLPfeatureXMLFileName = "inputNLPfeatureQuery.xml";
	bool useOutputQueryCFFFile = false;
	string outputQueryCFFFileName = "outputNLPQuery.cff";
	bool useInputQueryXMLFile = false;
	string inputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryXMLFile = false;
	string outputQueryXMLFileName = "semanticNetQuery.xml";
	bool useOutputQueryCXLFile = false;
	string outputQueryCXLFileName = "semanticNetQuery.cxl";
	bool useOutputQueryLDRFile = false;
	string outputQueryLDRFileName = "semanticNetQuery.ldr";
	bool useOutputQueryPPMFile = false;
	string outputQueryPPMFileName = "semanticNetQuery.ppm";
	bool useOutputQuerySVGFile = false;
	string outputQuerySVGFileName = "semanticNetQuery.svg";
	bool useOutputTextAllFile = false;
	string outputTextAllFileName = "semanticNet";
	#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
	bool useOutputTextAnswerPlainTXTFile = false;
	string outputTextAnswerPlainTXTFileName = "answer.txt";
	#endif

	#ifdef GIA_INPUT_FILE_LISTS
	bool inputFileList = false;	//not used by NLC
	#endif
	#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
	bool NLCinputFileList = false;
	#endif
	//#ifdef NLC_PREPROCESSOR
	bool useNLCpreprocessor = false;
	//#endif
	#ifdef NLC_API
	bool NLCapi = false;
	string APIsourceFolder = NLC_API_DEFAULT_SOURCE_FOLDER_NAME;
	string APIclassListFileName = NLC_API_DEFAULT_CLASS_LIST_FILE_NAME;
	#endif
	bool printOutput = false;
	bool printOutputQuery = false;
	bool displayInOpenGLAndOutputScreenshot = true;

	int rasterImageWidth = 640;
	int rasterImageHeight = 480;

	bool useInputQuery = false;

	#ifdef GIA_DATABASE
	bool readFromDatabase = false;
	bool writeToDatabase = false;
	bool useDatabase = false;
	string databaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
	#endif
	#ifdef GIA_SEMANTIC_PARSER
	string semanticParserDatabaseFolderName = GIA_DATABASE_FILESYSTEM_DEFAULT_SERVER_OR_MOUNT_NAME_BASE + GIA_SEMANTIC_PARSER_DATABASE_FILESYSTEM_DEFAULT_DATABASE_NAME;
	#endif

	#ifdef GIA_PREPROCESSOR
	bool useLRP = false;
	bool useOutputLRPTextPlainTXTFile = false;
	string outputLRPTextPlainTXTFileName = "inputTextWithLRP.txt";
	bool useOutputQueryLRPTextPlainTXTFile = false;
	string outputQueryLRPTextPlainTXTFileName = "inputTextWithLRPQuery.txt";
	string lrpDataFolderName = "";
	#endif

	#ifdef USE_WORDNET
	#ifdef GIA_SYNONYMN_DETECTION_DEFAULT_QUERIES_AND_ADVANCED_REFERENCING
	int synonymnDetectionStatus = SYNONYMN_DETECTION_STATUS_QUERIES_AND_ADVANCED_REFERENCING;
	#else
	int synonymnDetectionStatus = SYNONYMN_DETECTION_STATUS_QUERIES_ONLY;
	#endif
	#endif

	//bool train = false;
	//bool form = true;

	//basic execution flow outline; if no dataset or xml inputText file is specified, just form network - do not train network

	#ifdef USE_CE
	if(SHAREDvarsClass().argumentExists(argc, argv, "-icodeextensions"))
	#else
	if(SHAREDvarsClass().argumentExists(argc, argv, "-itxt") || SHAREDvarsClass().argumentExists(argc, argv, "-ionlprel") || SHAREDvarsClass().argumentExists(argc, argv, "-ixml"))
	#endif
	{
		if(SHAREDvarsClass().argumentExists(argc, argv, "-itxt"))
		{
			inputTextPlainTXTfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-itxt");
			useInputTextPlainTXTFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ionlprel"))
		{
			inputTextNLPrelationXMLfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ionlprel");
			useInputTextNLPrelationXMLFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ionlptag"))
		{
			inputTextNLPfeatureXMLfileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ionlptag");
			useInputTextNLPfeatureXMLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ixml"))
		{
			inputTextXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ixml");
			//train = true;
			useInputTextXMLFile = true;
		}

		#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ilist"))
		{
			NLCinputFileList = true;
		}
		#endif
		#ifdef NLC_PREPROCESSOR
		if(SHAREDvarsClass().argumentExists(argc, argv, "-ipreprocess"))
		{
			useNLCpreprocessor = true;
		}
		#endif
		#ifdef NLC_API
		if(SHAREDvarsClass().argumentExists(argc, argv, "-api"))
		{
			NLCapi = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-apisourcefolder"))
		{
			APIsourceFolder = SHAREDvarsClass().getStringArgument(argc, argv, "-apisourcefolder");
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-apiclasslist"))
		{
			APIclassListFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-apiclasslist");
		}
		#endif

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ocff"))
		{
			outputTextCFFFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ocff");
			useOutputTextCFFFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oxml"))
		{
			outputTextXMLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oxml");
			useOutputTextXMLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-ocxl"))
		{
			outputTextCXLFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-ocxl");
			useOutputTextCXLFile = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oldr"))
		{
			outputTextLDRFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oldr");
			useOutputTextLDRFile = true;
			printOutput = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oppm"))
		{
			outputTextPPMFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oppm");
			useOutputTextPPMFile = true;
			printOutput = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-osvg"))
		{
			outputTextSVGFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-osvg");
			useOutputTextSVGFile = true;
			printOutput = true;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-oall"))
		{
			outputTextAllFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-oall");
			useOutputTextAllFile = true;
			printOutput = true;
		}

		/*
		if(SHAREDvarsClass().argumentExists(argc, argv, "-train"))
		{
			int trainInt
			trainInt = SHAREDvarsClass().getFloatArgument(argc, argv, "-train");
			train = (bool)trainInt;
		}
		*/

		if(SHAREDvarsClass().argumentExists(argc, argv, "-notshow"))
		{
			displayInOpenGLAndOutputScreenshot = false;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-width"))
		{
			rasterImageWidth = SHAREDvarsClass().getFloatArgument(argc, argv, "-width");
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-height"))
		{
			rasterImageHeight = SHAREDvarsClass().getFloatArgument(argc, argv, "-height");
		}

		string currentFolder = SHAREDvarsClass().getCurrentDirectory();

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlprelation"))
		{
			NLPdependencyRelationsParser = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlprelation"));
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpfeature"))
		{
			NLPfeatureParser = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlpfeature"));
		}
		else
		{
			NLPfeatureParser = NLPdependencyRelationsParser;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpcompmode"))
		{
			if(queryNLPdependencyRelationsParser == GIA_NLP_PARSER_RELEX)
			{
				int nlpcompmode = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-nlpcompmode"));
				if(nlpcompmode == 1)
				{
					NLPrelexCompatibilityMode = true;
					NLPassumePreCollapsedStanfordRelations = true;
				}
				else if(nlpcompmode == 2)
				{
					NLPassumePreCollapsedStanfordRelations = true;
				}
			}
			else
			{
				cout << "error: nlpcompmode set but (NLPdependencyRelationsParser != GIA_NLP_PARSER_RELEX)" << endl;
				exit(EXIT_ERROR);
			}
		}

		#ifdef GIA_DATABASE
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbread"))
		{
			readFromDatabase = true;
			useDatabase = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbwrite"))
		{
			writeToDatabase = true;
			useDatabase = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbfolder"))
		{
			databaseFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-dbfolder");
			databaseFolderName = databaseFolderName + '/';
		}
		#endif
		#ifdef GIA_SEMANTIC_PARSER
		if(SHAREDvarsClass().argumentExists(argc, argv, "-dbsemanticparserfolder"))
		{
			semanticParserDatabaseFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-dbsemanticparserfolder");
			semanticParserDatabaseFolderName = semanticParserDatabaseFolderName + '/';
		}
		#endif

		#ifdef GIA_PREPROCESSOR
		if(SHAREDvarsClass().argumentExists(argc, argv, "-lrp"))
		{
			useLRP = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-olrptxt"))
		{
			outputLRPTextPlainTXTFileName = SHAREDvarsClass().getStringArgument(argc, argv, "-olrptxt");
			useOutputLRPTextPlainTXTFile = true;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-lrpfolder"))
		{
			lrpDataFolderName = SHAREDvarsClass().getStringArgument(argc, argv, "-lrpfolder");
			lrpDataFolderName = lrpDataFolderName + '/';
		}
		else
		{
			lrpDataFolderName = currentFolder;
		}
		#endif
		#ifdef USE_WORDNET
		if(SHAREDvarsClass().argumentExists(argc, argv, "-syndet"))
		{
			synonymnDetectionStatus = int(SHAREDvarsClass().getFloatArgument(argc, argv, "-syndet"));
		}
		#endif

		if(SHAREDvarsClass().argumentExists(argc, argv, "-inputfolder"))
		{
			inputFolder =SHAREDvarsClass().getStringArgument(argc, argv, "-inputfolder");
		}
		else
		{
			inputFolder = currentFolder;
		}

		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlprelexfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlprelexfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_RELEX] = currentFolder;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpstanfordcorenlpfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlpstanfordcorenlpfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_CORENLP] = currentFolder;
		}
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpstanfordparserfolder"))
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] = SHAREDvarsClass().getStringArgument(argc, argv, "-nlpstanfordparserfolder");
		}
		else
		{
			NLPexeFolderArray[GIA_NLP_PARSER_STANFORD_PARSER] = currentFolder;
		}
		#ifdef GIA_NLP_CLIENT_SERVER
		if(SHAREDvarsClass().argumentExists(argc, argv, "-nlpclient"))
		{
			NLPclient = true;
		}	
		#endif	
		

		if(SHAREDvarsClass().argumentExists(argc, argv, "-outputfolder"))
		{
			outputFolder = SHAREDvarsClass().getStringArgument(argc, argv, "-outputfolder");
		}
		else
		{
			outputFolder = currentFolder;
		}

		SHAREDvarsClass().setCurrentDirectory(inputFolder);

		if(SHAREDvarsClass().argumentExists(argc, argv, "-version"))
		{
			cout << "NLC.exe - Project Version: 2b1a 19-May-2017" << endl;
			exit(EXIT_OK);
		}


	}
	else
	{
		cout << "error: GIA requires either a plain text inputText file (.txt), an NPL parsed inputText file (.xml) or GIA semantic network (.xml) to be defined" << endl;
		printf(errmessage);
		exit(EXIT_ERROR);
	}

	//not currently used;
	if(!XMLrulesClassClass().parseNLCrulesXMLfile())
	{
		cout << "warning: NLCrules.xml file not detected" << endl;
		//exit(EXIT_ERROR);
	}

	#ifndef NLC_GIA_NLP_OR_XML_INPUT
	if(!useInputTextPlainTXTFile)
	{
		cout << "NLC requires useInputTextPlainTXTFile (itxt)" << endl;
	}
	#endif

	int numberOfInputFilesInList = 0;
	vector<string> inputTextPlainTXTFileNameList;
	#ifdef NLC_GIA_NLP_OR_XML_INPUT
	vector<string> inputTextNLPrelationXMLFileNameList;
	vector<string> inputTextNLPfeatureXMLFileNameList;
	vector<string> inputTextXMLFileNameList;
	#endif
	vector<string> functionNameList;

	#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE
	if(NLCinputFileList)
	{
		if(useInputTextPlainTXTFile)
		{
			if(!SHAREDvarsClass().getFilesFromFileList(inputTextPlainTXTfileName, &inputTextPlainTXTFileNameList, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextPlainTXTfileName << endl;
			}
			#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE_SUPPORT_PREPROCESSOR
			else
			{
				if(useNLCpreprocessor)
				{
					//collapse all input list text files into single input text file
					inputTextPlainTXTfileName = inputTextPlainTXTfileName + NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE_SUPPORT_PREPROCESSOR_COMBINED_FILE_NAME_APPEND_TEXT;
					string tempStr = "";
					SHAREDvarsClass().setCurrentDirectory(outputFolder);
					SHAREDvarsClass().writeStringToFile(inputTextPlainTXTfileName, &tempStr);
					SHAREDvarsClass().setCurrentDirectory(inputFolder);
					for(vector<string>::iterator inputTextPlainTXTFileNameListIter = inputTextPlainTXTFileNameList.begin(); inputTextPlainTXTFileNameListIter != inputTextPlainTXTFileNameList.end(); inputTextPlainTXTFileNameListIter++)
					{
						string inputTextPlainTXTfileNameSeparate = *inputTextPlainTXTFileNameListIter;
						string NLCfunctionName = NLCmainClass().removeNLCfileNameExtension(inputTextPlainTXTfileNameSeparate);
						string functionName = "";
						string functionOwnerName = "";
						string functionObjectName = "";
						bool hasFunctionOwnerClass = false;
						bool hasFunctionObjectClass = false;
						NLCitemClassClass().parseFunctionNameFromNLCfunctionName(NLCfunctionName, &functionName, &functionOwnerName, &hasFunctionOwnerClass, &functionObjectName, &hasFunctionObjectClass);
						string NLCfunctionHeader = NLCitemClassClass().generateNLCfunctionHeader(functionName, functionOwnerName, hasFunctionOwnerClass, functionObjectName, hasFunctionObjectClass);
						string functionContents = SHAREDvarsClass().getFileContents(inputTextPlainTXTfileNameSeparate);
						string functionText = NLCfunctionHeader + CHAR_NEWLINE + functionContents + CHAR_NEWLINE;
						SHAREDvarsClass().setCurrentDirectory(outputFolder);
						SHAREDvarsClass().appendStringToFile(inputTextPlainTXTfileName, &functionText);
						SHAREDvarsClass().setCurrentDirectory(inputFolder);
					}
					SHAREDvarsClass().setCurrentDirectory(outputFolder);	//this is required such that NLC preprocessor can read the combined input file
					inputTextPlainTXTFileNameList.clear();	//this is required such that NLC preprocessor can fill inputTextPlainTXTFileNameList
					numberOfInputFilesInList = 1;		//this is required such that NLC preprocessor can fill inputTextPlainTXTFileNameList
				}
			}
			#endif
		}
		#ifdef NLC_GIA_NLP_OR_XML_INPUT
		if(useInputTextNLPrelationXMLFile)
		{
			if(!SHAREDvarsClass().getFilesFromFileList(inputTextNLPrelationXMLfileName, &inputTextNLPrelationXMLFileNameList, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextNLPrelationXMLfileName << endl;
			}
		}
		if(useInputTextNLPfeatureXMLFile)
		{
			if(!SHAREDvarsClass().getFilesFromFileList(inputTextNLPfeatureXMLfileName, &inputTextNLPfeatureXMLFileNameList, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextNLPfeatureXMLfileName << endl;
			}
		}
		if(useInputTextXMLFile)
		{
			if(!SHAREDvarsClass().getFilesFromFileList(inputTextXMLFileName, &inputTextXMLFileNameList, &numberOfInputFilesInList))
			{
				cout << "main{} error: !getFilesFromFileList: " << inputTextXMLFileName << endl;
			}
		}
		#endif
	}
	#endif

	//#ifdef NLC_PREPROCESSOR
	NLCfunction* firstNLCfunctionInList = new NLCfunction();
	//#endif
	#ifdef NLC_PREPROCESSOR
	//vector<string> inputTextPlainTXTFileNameList;
	bool preprocessorDetectedFunctions = false;
	string inputTextPlainTXTfileNameOrig = inputTextPlainTXTfileName;
	if(useNLCpreprocessor)
	{
		string outputPreprocessedTextForNLConlyPlainTXTFileName = inputTextPlainTXTfileName + NLC_PREPROCESSOR_PREPROCESSED_FILE_NAME_APPEND_TEXT;
		#ifdef NLC_GIA_NLP_OR_XML_INPUT
		if(!useInputTextPlainTXTFile)
		{
			cout << "useNLCpreprocessor (ipreprocess) requires useInputTextNLPrelationXMLFile (itxt)" << endl;
		}
		if(useInputTextNLPrelationXMLFile || useInputTextNLPfeatureXMLFile || useInputTextXMLFile)
		{
			cout << "useNLCpreprocessor (ipreprocess) does not support useInputTextNLPrelationXMLFile (ionlprel), useInputTextNLPfeatureXMLFile (ionlptag), and useInputTextXMLFile (ixml)" << endl;
		}
		#endif

		if(NLCpreprocessorClass().preprocessTextForNLC(inputTextPlainTXTfileName, firstNLCfunctionInList, &preprocessorDetectedFunctions, &numberOfInputFilesInList, &inputTextPlainTXTFileNameList, outputPreprocessedTextForNLConlyPlainTXTFileName))
		{
			#ifdef NLC_INPUT_FUNCTION_LISTS_PREPROCESSOR
			if(preprocessorDetectedFunctions)
			{
				NLCinputFileList = true;
			}
			else
			{
			#endif
				inputTextPlainTXTfileNameOrig = inputTextPlainTXTfileName;
				inputTextPlainTXTfileName = outputPreprocessedTextForNLConlyPlainTXTFileName;	//execute NLP on preprocessed file
			#ifdef NLC_INPUT_FUNCTION_LISTS_PREPROCESSOR
			}
			#endif
		}
		else
		{
			cout << "main{} error: !preprocessTextForNLC{}" << endl;
			exit(EXIT_ERROR);
		}
	}
	#endif


	vector<NLCclassDefinition*> classDefinitionList;
	vector<NLCcodeblock*> firstCodeBlockInTreeList;
	vector<vector<GIAentityNode*>*> entityNodesActiveListCompleteFunctions;
	vector<map<int, vector<GIAentityNode*>*>*> entityNodesActiveListSentencesFunctions;

	#ifdef NLC_ADVANCED_REFERENCING_SUPPORT_ALIASES_PREVENT_ADDING_AS_FUNCTION_ARGUMENT
	#ifdef NLC_ADVANCED_REFERENCING_SUPPORT_ALIASES_CROSS_FUNCTION_ALIASES
	NLCcodeBlockClassClass().initialiseFunctionAliasClassList();
	#endif
	#endif

	#ifdef NLC_LIBRARY_FUNCTION_LISTS_FOR_ARGUMENT_RECONCILIATION
	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS
	//added 1p3b - add functionDefinitionClassDefinition (with functionDependency) for every NLClibraryStandard and NLClibraryUser function (not NLClibraryBase functions; whose references are automatically generated by NLC)
	//parse list of NLClibraryStandardFunctionList.txt and NLClibraryUserFunctionList.txt
	vector<string> nlcLibraryFunctionList;
	int nlcLibraryFunctionListSizeTemp;
	#ifdef NLC_LIBRARY_STANDARD
	if(!SHAREDvarsClass().getFilesFromFileList(NLC_LIBRARY_STANDARD_FUNCTION_LIST_FILE_NAME, &nlcLibraryFunctionList, &nlcLibraryFunctionListSizeTemp))
	{
		#ifndef NLC_LIBRARY_DISABLE_FUNCTIONS_LIST_WARNING
		cout << "main{} warning: " << NLC_LIBRARY_STANDARD_FUNCTION_LIST_FILE_NAME << " function arguments will not be reconciled" << endl;
		#endif
	}
	#endif
	#ifdef NLC_LIBRARY_USER
	if(!SHAREDvarsClass().getFilesFromFileList(NLC_LIBRARY_USER_FUNCTION_LIST_FILE_NAME, &nlcLibraryFunctionList, &nlcLibraryFunctionListSizeTemp))
	{
		#ifndef NLC_LIBRARY_DISABLE_FUNCTIONS_LIST_WARNING
		cout << "main{} warning: " << NLC_LIBRARY_USER_FUNCTION_LIST_FILE_NAME << " function arguments will not be reconciled" << endl;
		#endif
	}
	#endif
	for(vector<string>::iterator nlcLibraryFunctionListIter = nlcLibraryFunctionList.begin(); nlcLibraryFunctionListIter != nlcLibraryFunctionList.end(); nlcLibraryFunctionListIter++)
	{
		string nlcLibraryFunctionName = (*nlcLibraryFunctionListIter);
		if(NLCpreprocessorClass().detectFunctionHeader(&nlcLibraryFunctionName))
		{
			string NLCfunctionName = NLCpreprocessorClass().getFunctionNameFromFunctionHeader(&nlcLibraryFunctionName);
			NLCtranslatorClass().createFunctionDefinitionClassDefinition(&classDefinitionList, NLCfunctionName, FUNCTION_INDEX_LIBRARY_FUNCTION, true);
		}
		else
		{
			cout << "main{} error: !detectFunctionHeader: nlcLibraryFunctionName = " << nlcLibraryFunctionName << endl;
		}
	}
	#endif
	#endif

	//#ifdef NLC_PREPROCESSOR
	NLCfunction* currentNLCfunctionInList = firstNLCfunctionInList;
	//#endif
	for(int functionDefinitionIndex=0; functionDefinitionIndex<numberOfInputFilesInList; functionDefinitionIndex++)
	{
		NLCcodeblock* firstCodeBlockInTree = new NLCcodeblock();
		firstCodeBlockInTreeList.push_back(firstCodeBlockInTree);

		GIAtranslatorVariablesClass* translatorVariables = new GIAtranslatorVariablesClass();
		translatorVariables->isQuery = false;
		translatorVariables->entityNodesActiveListComplete = new vector<GIAentityNode*>;
		translatorVariables->entityNodesActiveListNetworkIndexes = new unordered_map<string, GIAentityNode*>;
		translatorVariables->timeConditionNodesActiveList = new unordered_map<long, GIAtimeConditionNode*>;
		translatorVariables->entityNodesActiveListSentences = new map<int, vector<GIAentityNode*>*>;
		entityNodesActiveListCompleteFunctions.push_back(translatorVariables->entityNodesActiveListComplete);
		entityNodesActiveListSentencesFunctions.push_back(translatorVariables->entityNodesActiveListSentences);
		translatorVariables->NLPfeatureParser = NLPfeatureParser;
		translatorVariables->NLPdependencyRelationsParser = NLPdependencyRelationsParser;
		translatorVariables->NLPrelexCompatibilityMode = NLPrelexCompatibilityMode;
		translatorVariables->NLPassumePreCollapsedStanfordRelations = NLPassumePreCollapsedStanfordRelations;
		#ifdef GIA_NLP_CLIENT_SERVER
		translatorVariables->NLPclient = NLPclient;
		#endif
		GIAtranslatorVariablesClass* translatorVariablesQuery = NULL;	//not used by NLC;
		
		#ifdef NLC_INPUT_FUNCTION_LISTS
		if(NLCinputFileList)
		{
			if(useInputTextPlainTXTFile)
			{
				inputTextPlainTXTfileName = inputTextPlainTXTFileNameList.at(functionDefinitionIndex);
			}
			#ifdef NLC_GIA_NLP_OR_XML_INPUT
			if(useInputTextNLPrelationXMLFile)
			{
				inputTextNLPrelationXMLfileName = inputTextNLPrelationXMLFileNameList.at(functionDefinitionIndex);
			}
			if(useInputTextNLPfeatureXMLFile)
			{
				inputTextNLPfeatureXMLfileName = inputTextNLPfeatureXMLFileNameList.at(functionDefinitionIndex);
			}
			if(useInputTextXMLFile)
			{
				inputTextXMLFileName = inputTextXMLFileNameList.at(functionDefinitionIndex);
			}
			#endif
		}
		#endif

		SHAREDvarsClass().setCurrentDirectory(inputFolder);	//NB executeGIA must be executed with current directory set to the original inputFolder (such that GIArules.xml can be read)
		string inputFolderOrig = inputFolder;
		#ifdef NLC_PREPROCESSOR
		if(useNLCpreprocessor)
		{
			inputFolder = outputFolder;	//this is required such that GIA uses the output folder as its input folder (ie inputFolder), considering NLP has already written its output to this folder
		}
		#endif

		NLCtranslatorCodeBlocksOperationsClass().setFirstNLCsentenceInList(currentNLCfunctionInList->firstNLCsentenceInFunction);
		#ifdef GIA_NLC_INTEGRATION
		GIAtranslatorOperationsClass().setFirstNLCsentenceInListGIA(currentNLCfunctionInList->firstNLCsentenceInFunction);
		#endif

		#ifdef USE_CS_WORKAROUND
		GIAmainClass().executeGIA2();
		#endif
		GIAmainClass().executeGIA(

			translatorVariables,
			translatorVariablesQuery,

			NLPexeFolderArray,

			useInputTextPlainTXTFile,
			inputTextPlainTXTfileName,

			#ifdef USE_CE
			useInputTextCodeextensionsTXTFileName,
			inputTextCodeextensionsTXTFileName,
			#endif

			useInputTextNLPrelationXMLFile,
			inputTextNLPrelationXMLfileName,
			useInputTextNLPfeatureXMLFile,
			inputTextNLPfeatureXMLfileName,
			useOutputTextCFFFile,
			outputTextCFFFileName,
			useInputTextXMLFile,
			inputTextXMLFileName,
			useOutputTextXMLFile,
			outputTextXMLFileName,
			useOutputTextCXLFile,
			outputTextCXLFileName,
			useOutputTextLDRFile,
			outputTextLDRFileName,
			useOutputTextPPMFile,
			outputTextPPMFileName,
			useOutputTextSVGFile,
			outputTextSVGFileName,
			useInputQueryPlainTXTFile,
			inputQueryPlainTXTFileName,
			useInputQueryNLPrelationXMLFile,
			inputQueryNLPrelationXMLFileName,
			useInputQueryNLPfeatureXMLFile,
			inputQueryNLPfeatureXMLFileName,
			useOutputQueryCFFFile,
			outputQueryCFFFileName,
			useInputQueryXMLFile,
			inputQueryXMLFileName,
			useOutputQueryXMLFile,
			outputQueryXMLFileName,
			useOutputQueryCXLFile,
			outputQueryCXLFileName,
			useOutputQueryLDRFile,
			outputQueryLDRFileName,
			useOutputQueryPPMFile,
			outputQueryPPMFileName,
			useOutputQuerySVGFile,
			outputQuerySVGFileName,
			useOutputTextAllFile,
			outputTextAllFileName,
			#ifdef GIA_QUERY_WRITE_ANSWER_TO_FILE
			useOutputTextAnswerPlainTXTFile,
			outputTextAnswerPlainTXTFileName,
			#endif

			#ifdef GIA_INPUT_FILE_LISTS
			inputFileList,
			#endif
			printOutput,
			printOutputQuery,
			displayInOpenGLAndOutputScreenshot,

			rasterImageWidth,
			rasterImageHeight,

			useInputQuery,

			#ifdef GIA_DATABASE
			readFromDatabase,
			writeToDatabase,
			useDatabase,
			databaseFolderName,
			#endif

			#ifdef GIA_SEMANTIC_PARSER
			semanticParserDatabaseFolderName,
			#endif

			#ifdef GIA_PREPROCESSOR
			useLRP,
			useOutputLRPTextPlainTXTFile,
			outputLRPTextPlainTXTFileName,
			useOutputQueryLRPTextPlainTXTFile,
			outputQueryLRPTextPlainTXTFileName,
			lrpDataFolderName,
			#endif

			#ifdef USE_WORDNET
			synonymnDetectionStatus
			#endif
		);

		SHAREDvarsClass().setCurrentDirectory(outputFolder);	//redundant	//NB executeGIA will change the current directory to the outputFolder, meaning NLC does not have to set the current directory to the outputFolder after executing GIA
		inputFolder = inputFolderOrig;

		string NLCfunctionName = "";
		#ifdef NLC_PREDEFINED_FUNCTION_NAME_FOR_NATURAL_LANGUAGE_CODE_WITHOUT_FUNCTION_SPECIFIED
		if(NLCinputFileList)
		{
			NLCfunctionName = inputTextPlainTXTfileName;
			NLCfunctionName = NLCmainClass().removeNLCfileNameExtension(NLCfunctionName);
		}
		else
		{
			NLCfunctionName = NLC_PREDEFINED_FUNCTION_NAME_FOR_NATURAL_LANGUAGE_CODE_WITHOUT_FUNCTION_SPECIFIED_NAME;
		}
		#else
		if(useInputTextPlainTXTFile)
		{
			#ifdef NLC_PREPROCESSOR
			if(useNLCpreprocessor && !NLCinputFileList)
			{
				NLCfunctionName = inputTextPlainTXTfileNameOrig;	//NLC 1i2c - do not add "afterPreprocessedforNLConly" to function name
			}
			else
			{
			#endif
				NLCfunctionName = inputTextPlainTXTfileName;
			#ifdef NLC_PREPROCESSOR
			}
			#endif
		}
		#ifdef NLC_GIA_NLP_OR_XML_INPUT
		else if(useInputTextNLPrelationXMLFile)
		{
			NLCfunctionName = inputTextNLPrelationXMLfileName;
		}
		else if(useInputTextNLPfeatureXMLFile)
		{
			NLCfunctionName = inputTextNLPfeatureXMLfileName;
		}
		else if(useInputTextXMLFile)
		{
			NLCfunctionName = inputTextXMLFileName;
		}
		else
		{
			cout << "error: NLC requires useInputTextPlainTXTFile or (useInputTextNLPrelationXMLFile and useInputTextNLPfeatureXMLFile) or useInputTextXMLFile" << endl;
		}
		#else
		else
		{
			cout << "error: NLC requires useInputTextPlainTXTFile" << endl;
		}
		#endif


		#ifdef NLC_STRICT_MODE_FAVOUR_COMPILATION_RATHER_THAN_DESIGN_USE_MAIN_ENTRY_POINT
		NLCfunctionName = progLangMainEntryPointFunctionName[progLang];
		#else
		NLCfunctionName = NLCmainClass().removeFileNameExtensions(NLCfunctionName);
		#endif
		#endif

		#ifdef NLC_INPUT_FUNCTION_LISTS
		functionNameList.push_back(NLCfunctionName);
		#endif



		//generate class definition function declaration for new function definition (creates both functionDependency object and classDefinition object)
		NLCtranslatorClass().createFunctionDefinitionClassDefinition(&classDefinitionList, NLCfunctionName, functionDefinitionIndex, false);

		NLCtranslatorClass().translateNetwork(firstCodeBlockInTree, &classDefinitionList, translatorVariables->entityNodesActiveListComplete, translatorVariables->entityNodesActiveListSentences, translatorVariables->maxNumberSentences, NLCfunctionName, currentNLCfunctionInList, useNLCpreprocessor);

		#ifdef NLC_PREPROCESSOR
		if(useNLCpreprocessor)
		{
			currentNLCfunctionInList = currentNLCfunctionInList->next;
		}
		#endif
	}


	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS
	if(!NLCmainClass().generateClassDefinitionFunctionDeclarationsAndReconcileArguments(numberOfInputFilesInList, &classDefinitionList, &entityNodesActiveListCompleteFunctions, &firstCodeBlockInTreeList))
	{
		result = false;
	}
	#endif

	#ifdef NLC_PREVENT_INHERITANCE_DOUBLE_DECLARATIONS_OF_CLASS_LIST_VARIABLES
	NLCtranslatorClassDefinitionsClass().preventDoubleDeclarationsOfClassDefinitionVariablesInHeirachy(&classDefinitionList);	//moved 1q9a
	#endif

	string code = "";

	#ifdef NLC_API
	vector<string> APIclassList;
	int numberOfFilesInAPIclassList = 0;
	if(NLCapi)
	{
		#ifdef NLC_API_SEPARATE_FILE_FOR_WRAPPER_FUNCTIONS
		vector<NLCclassDefinition*>* classDefinitionListAPI = &classDefinitionList;
		#else
		vector<NLCclassDefinition*>* classDefinitionListAPI = new vector<NLCclassDefinition*>;
		#endif
		if(!SHAREDvarsClass().getFilesFromFileList(APIclassListFileName, &APIclassList, &numberOfFilesInAPIclassList))
		{
			cout << "main{} error: !getFilesFromFileList: " << APIclassListFileName << endl;
		}
		for(vector<string>::iterator iter = APIclassList.begin(); iter != APIclassList.end(); iter++)
		{
			string APIclassName = *iter;
			if(!NLCapiClass().parseDoxygenClassXMLfile(APIclassName, APIsourceFolder, classDefinitionListAPI, progLang))
			{
				cout << "main{} error: !NLCapiClass().parseDoxygenClassXMLfile(: " << APIsourceFolder + "..." + APIclassName + "..." << endl;
			}
		}
		#ifdef NLC_API_SEPARATE_FILE_FOR_WRAPPER_FUNCTIONS
		#else
		if(NLCprintClassDefinitionsClass().printClassDefinitions(classDefinitionListAPI, progLang, &code, true, firstNLCfunctionInList))
		{

		}
		#endif
	}
	#endif

	#ifdef NLC_INPUT_FUNCTION_LISTS
	#ifndef NLC_NONOO_DISABLE_CLASS_HEIRACHY
	if(!NLCprintClassDefinitionsClass().printClassDefinitions(&classDefinitionList, progLang, &code, false, firstNLCfunctionInList))
	{
		result = false;
	}
	#endif
	#endif

	#ifndef NLC_LIBRARY
	//create predefined NLC functions
	NLCcodeblock* currentCodeBlockInTree = firstCodeBlockInTreeList.at(numberOfInputFilesInList-1);	//get firstCodeBlockInTreeList in last function
	NLCmainClass().printPredefinedNLCfunctions(currentCodeBlockInTree);
	#endif

	for(int functionDefinitionIndex=0; functionDefinitionIndex<numberOfInputFilesInList; functionDefinitionIndex++)
	{
		NLCcodeblock* firstCodeBlockInTree = firstCodeBlockInTreeList.at(functionDefinitionIndex);
		int level = 0;
		#ifdef NLC_INPUT_FUNCTION_LISTS
		if(!NLCprintCodeBlocksClass().printCodeBlocks(firstCodeBlockInTree, &classDefinitionList, progLang, &code, level))
		{
			result = false;
		}
		#else
		if(!NLCprintClass().printCode(firstCodeBlockInTree, &classDefinitionList, progLang, &code, firstNLCfunctionInList))
		{
			result = false;
		}
		#endif
	}
	#ifndef NLC_LIBRARY_GENERATE_INDIVIDUAL_FILES_ADD_CLASS_FUNCTIONS_TO_CLASS_DEFINITIONS
	cout << "code = \n" << code << endl;
	#endif

	//print execution time (end)
	time(&now);
	current = localtime(&now);
	sprintf(timeAndDateString, "%i:%i:%i %.2i/%.2i/%i", current->tm_hour, current->tm_min, current->tm_sec, current->tm_mday, (current->tm_mon+1), (current->tm_year + TM_STRUCT_YEAR_OFFSET));
	cout << "NLC execution time: " << timeAndDateString << " (finish)" << endl;
}

string NLCmainClass::removeFileNameExtensions(string NLCfunctionName)
{
	string NLCfunctionNameCleaned = NLCfunctionName;
	int indexOfFirstFileExtension = NLCfunctionName.find(".");
	if(indexOfFirstFileExtension != CPP_STRING_FIND_RESULT_FAIL_VALUE)
	{
		NLCfunctionNameCleaned = NLCfunctionName.substr(0, indexOfFirstFileExtension);
	}
	return NLCfunctionNameCleaned;
}

string NLCmainClass::removeNLCfileNameExtension(string NLCfunctionName)
{
	string NLCfunctionNameCleaned = NLCfunctionName;
	int indexOfFirstFileExtension = NLCfunctionName.find(NLC_NATURAL_LANGUAGE_CODE_FILE_NAME_EXTENSION);
	if(indexOfFirstFileExtension != CPP_STRING_FIND_RESULT_FAIL_VALUE)
	{
		NLCfunctionNameCleaned = NLCfunctionName.substr(0, indexOfFirstFileExtension);
	}
	#ifdef NLC_INPUT_FUNCTION_LISTS_EXPLICIT_FROM_DEDICATED_FILE_ENFORCE_NLC_FILE_EXTENSIONS
	else
	{
		cout << "removeNLCfileNameExtension{} error: .nlc (natural language code) file extension expected, NLCfunctionName = " << NLCfunctionName << endl;
		exit(EXIT_ERROR);
	}
	#endif
	return NLCfunctionNameCleaned;
}





#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS
bool NLCmainClass::generateClassDefinitionFunctionDeclarationsAndReconcileArguments(const int numberOfInputFilesInList, vector<NLCclassDefinition*>* classDefinitionList, vector<vector<GIAentityNode*>*>* entityNodesActiveListCompleteFunctions, vector<NLCcodeblock*>* firstCodeBlockInTreeList)
{
	bool result = true;

	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE
	//added 1k13g - generate class definition function declarations for all function execution references (generateClassHeirarchyFunctions has been separated from generateClassHeirarchy since non-exact function reconciliation can only occur once class definition heirachy has been established)
	for(int functionDefinitionIndex=0; functionDefinitionIndex<numberOfInputFilesInList; functionDefinitionIndex++)
	{
		NLCclassDefinition* functionDefinitionClassDefinition = NULL;
		if(NLCclassDefinitionClass.findFunctionDependencyClassDefinitionInListByIndex(classDefinitionList, functionDefinitionIndex, &functionDefinitionClassDefinition))
		{
			vector<GIAentityNode*>* entityNodesActiveListComplete = entityNodesActiveListCompleteFunctions->at(functionDefinitionIndex);

			//NLC translator Part 2b.
			if(!NLCtranslatorClassDefinitions.generateClassHeirarchyFunctions(classDefinitionList, entityNodesActiveListComplete, functionDefinitionClassDefinition))
			{
				result = false;
			}
		}
	}
	#endif



	#ifdef NLC_INPUT_FUNCTION_LISTS
	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_ACTIVE
	bool stillUnreconciledFunctionDeclarationArguments = true;
	while(stillUnreconciledFunctionDeclarationArguments)
	{
		stillUnreconciledFunctionDeclarationArguments = false;
		for(vector<NLCclassDefinition*>::iterator classDefinitionListIter = classDefinitionList->begin(); classDefinitionListIter != classDefinitionList->end(); classDefinitionListIter++)
		{
			NLCclassDefinition* classDefinition = *classDefinitionListIter;
			if(classDefinition->functionDependency != NULL)
			{
				NLCclassDefinitionFunctionDependency* functionDefinitionFunctionDependency = classDefinition->functionDependency;
				#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
				if(functionDefinitionFunctionDependency->functionDefinitionListIndex != FUNCTION_INDEX_LIBRARY_FUNCTION)	//redundant check (NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES: functionDependencies are now only defined for functionDefinition classDefinitions)
				#else
				if(functionDefinitionFunctionDependency->functionDefinitionListIndex != INT_DEFAULT_VALUE)	//redundant check (NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES: functionDependencies are now only defined for functionDefinition classDefinitions)
				#endif
				{
					if(!(functionDefinitionFunctionDependency->isReferenceElseFunctionDefinition))	//redundant check (checking functionDefinitionListIndex already)
					{
						if(!(functionDefinitionFunctionDependency->reconciledFunctionDeclarationArguments))
						{
							bool reconciledChildFunctionDeclarationArguments = true;
							for(vector<NLCclassDefinition*>::iterator classDefinitionListIter2 = classDefinition->functionDependencyList.begin(); classDefinitionListIter2 != classDefinition->functionDependencyList.end(); classDefinitionListIter2++)
							{
								NLCclassDefinitionFunctionDependency* functionDefinitionFunctionDependencyChild = (*classDefinitionListIter2)->functionDependency;
								#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
								if(functionDefinitionFunctionDependencyChild->functionDefinitionListIndex != FUNCTION_INDEX_LIBRARY_FUNCTION)
								#else
								if(functionDefinitionFunctionDependencyChild->functionDefinitionListIndex != INT_DEFAULT_VALUE)
								#endif
								{
									if(!(functionDefinitionFunctionDependencyChild->isReferenceElseFunctionDefinition))	//redundant check (checking functionDefinitionListIndex already)
									{
										if(!(functionDefinitionFunctionDependencyChild->reconciledFunctionDeclarationArguments))
										{
											reconciledChildFunctionDeclarationArguments = false;
										}
									}
									else
									{
										cout << "NLCmain error: functionDefinitionFunctionDependencyChild->functionDefinitionListIndex != INT_DEFAULT_VALUE && functionDefinitionFunctionDependencyChild->isReferenceElseFunctionDefinition" << endl;
										exit(EXIT_ERROR);
									}
								}
								#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
								#ifndef NLC_LIBRARY
								else
								{
									cout << "NLCmain error: functionDefinitionFunctionDependencyChild->functionDefinitionListIndex == INT_DEFAULT_VALUE. FunctionDependencies are only defined for functionDefinition classDefinitions" << endl;
									exit(EXIT_ERROR);
								}
								#endif
								#endif
							}
							if(reconciledChildFunctionDeclarationArguments)
							{
								//updates all classDefinition functionList function declaration arguments corresponding to a single defined function (functionDefinitionFunctionDependency->functionDefinitionListIndex)

								NLCcodeblock* firstCodeBlockInTree = firstCodeBlockInTreeList->at(functionDefinitionFunctionDependency->functionDefinitionListIndex);

								NLCtranslator.reconcileFunctionDefinitionClassDefinitionArgumentsBasedOnImplicitlyDeclaredVariablesInCurrentFunctionDefinition(firstCodeBlockInTree, classDefinitionList, classDefinition);

								functionDefinitionFunctionDependency->reconciledFunctionDeclarationArguments = true;
							}
							stillUnreconciledFunctionDeclarationArguments = true;
						}
					}
					else
					{
						cout << "NLCmain error: functionDefinitionFunctionDependency->functionDefinitionListIndex != INT_DEFAULT_VALUE && functionDefinitionFunctionDependency->isReferenceElseFunctionDefinition" << endl;
						exit(EXIT_ERROR);
					}
				}
				#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
				#ifndef NLC_LIBRARY
				else
				{
					cout << "NLCmain error: functionDefinitionFunctionDependency->functionDefinitionListIndex == INT_DEFAULT_VALUE. FunctionDependencies are only defined for functionDefinition classDefinitions" << endl;
					exit(EXIT_ERROR);
				}
				#endif
				#endif
			}
		}
	}
	#else
	for(int functionDefinitionIndex=0; functionDefinitionIndex<numberOfInputFilesInList; functionDefinitionIndex++)
	{
		NLCclassDefinition* functionDefinitionClassDefinition = NULL;
		if(NLCclassDefinitionClass.findFunctionDependencyClassDefinitionInListByIndex(&functionDependencyList, functionDefinitionIndex, &functionDefinitionClassDefinition))
		{
			if(functionDefinitionClassDefinition->functionDependency != NULL)
			{
				NLCclassDefinitionFunctionDependency* functionDefinitionFunctionDependency = functionDefinitionClassDefinition->functionDependency;
				if(functionDefinitionFunctionDependency->functionDefinitionListIndex != INT_DEFAULT_VALUE)
				{
					//updates all classDefinition functionList function declaration arguments corresponding to a single defined function (functionDefinitionFunctionDependency->functionDefinitionListIndex)

					NLCcodeblock* firstCodeBlockInTree = firstCodeBlockInTreeList->at(functionDefinitionFunctionDependency->functionDefinitionListIndex);

					isLibraryFunction = false;

					NLCtranslator.reconcileFunctionDefinitionClassDefinitionArgumentsBasedOnImplicitlyDeclaredVariablesInCurrentFunctionDefinition(firstCodeBlockInTree, &classDefinitionList, functionDefinitionClassDefinition);

					//update variable names in function to 'this' if necessary based on formalFunctionArgumentCorrespondsToActionSubjectUseThisAlias
				}
				#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS_RECURSIVE_DO_NOT_ADD_FUNCTION_DEPENDENCY_FOR_FUNCTION_REFERENCES
				#ifndef NLC_LIBRARY
				else
				{
					cout << "NLCmain error: functionDefinitionFunctionDependency->functionDefinitionListIndex == INT_DEFAULT_VALUE. FunctionDependencies are only defined for functionDefinition classDefinitions" << endl;
					exit(EXIT_ERROR);
				}
				#endif
				#endif

			}
		}
	}
	#endif
	#endif

	return result;
}
#endif


#ifndef NLC_LIBRARY
void NLCmainClass::printPredefinedNLCfunctions(NLCcodeblock* currentCodeBlockInTree);
{
	//create predefined NLC functions
	currentCodeBlockInTree = NLCcodeBlockClass.getLastCodeBlockInLevel(currentCodeBlockInTree);
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockAddEntityToCategoryListCheckLastSentenceReferencedPluralNewFunction(currentCodeBlockInTree);
	#ifdef NLC_ADVANCED_REFERENCING
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockAddEntityToCategoryListCheckLastSentenceReferencedSingularNewFunction(currentCodeBlockInTree);
	#ifdef NLC_ADVANCED_REFERENCING_MONITOR_CONTEXT
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksAddEntityToContextLevelListNewFunction(currentCodeBlockInTree);
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksClearContextListNewFunction(currentCodeBlockInTree);
	#endif
	#endif
	#ifndef NLC_NONOO
	#ifdef NLC_RECONCILE_CLASS_DEFINITION_LIST_FUNCTION_DECLARATION_ARGUMENTS
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksCastVectorNewFunction(currentCodeBlockInTree);
	#endif
	#endif
	#ifdef NLC_ADVANCED_REFERENCING_SUPPORT_ALIASES
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksFindAliasAndAddToCategoryListNewFunction(currentCodeBlockInTree);
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlocksFindAliasNewFunction(currentCodeBlockInTree);
	#endif
	#ifdef NLC_REDEFINITIONS
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockCheckParentClassNameNewFunction(currentCodeBlockInTree);
	#endif
	#ifdef NLC_NON_LIBRARY_FUNCTIONS_EXTENDED
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockAddPropertyNewFunction(currentCodeBlockInTree);
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeBlockAddConditionNewFunction(currentCodeBlockInTree);
	#endif
	#ifdef NLC_TRANSLATOR_TEST_DEFINITE_ENTITY_EXISTENCE
	currentCodeBlockInTree = NLCcodeBlockClass.createCodeVerifyDefiniteReferenceExistenceNewFunction(currentCodeBlockInTree);	
	#endif
}
#endif


