/*******************************************************************************
 *
 * This file is part of NLC.
 *
 * NLC is commercially licensed software. It may not be redistributed,
 * and may only be used by a registered licensee.
 *
 * NLC is sold in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * BAI Commercial License for more details
 * (a copy is included in the LICENSE file that accompanied this code).
 *
 * You will have received a copy of the BAI Commercial License
 * along with NLC. For more information, visit <http://www.baxterai.com>
 *
 *******************************************************************************/

/*******************************************************************************
 *
 * File Name: NLClibraryStandardMove.cpp
 * Author: Richard Bruce Baxter - Copyright (c) 2005-2015 Baxter AI (baxterai.com)
 * Project: Natural Language Compiler (Programming Interface)
 * Project Version: 1p1a 06-June-2015
 * Requirements: requires C++ code to be generated by NLC
 *
 *******************************************************************************/
 
#include "NLClibraryStandardMove.h"

//e.g. Move the chicken from the pie to the apple.
void moveFunction(vector<moveClass*> &moveClassList, vector<NLCgenericEntityClass*> &moveObjectClassList)
{
	for(vector<NLCgenericEntityClass*> ::iterator iter1 = moveClassList.begin(); iter1 < moveClassList.end(); iter1++) 
	{
		moveAction = *iter2;
		unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*> * NLCgenericEntityFromConditionList = getConditionListByConditionName(moveAction, NLC_USE_LIBRARY_MOVE_FUNCTION_ACTION_CONDITION_FROM_NAME); 
		unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*> * NLCgenericEntityToConditionList = getConditionListByConditionName(moveAction, NLC_USE_LIBRARY_MOVE_FUNCTION_ACTION_CONDITION_TO_NAME); 

		/*these adjustments are now handled by GIA_DYNAMICALLY_LINK_FROM_CONDITIONS:linkEntitiesDynamicFromConditions;
		
		//This workaround is not possible as the to condition object context will be parsed by NLC (rather than the to condition object being added to from condition object by NLC). So therefore * must upgrade either Stanford NLP or GIA to attach the to condition object to the object entity (which is the correct interpretation)
		if(NLCgenericEntityToConditionList == NULL)		//Stanford Parser/GIA usually connects "to" condition to the from condition object if there is a preceeding "from" condition
		{
			if(NLCgenericEntityFromConditionList != NULL)
			{
				for(unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*> ::iterator iter1 = NLCgenericEntityFromConditionList.begin(); iter1 != NLCgenericEntityFromConditionList.end(); iter1++) 
				{
					NLCgenericEntityClass* fromConditionObject = iter1->second;
					NLCgenericEntityToConditionList = getConditionListByConditionName(fromConditionObject, NLC_USE_LIBRARY_MOVE_FUNCTION_ACTION_CONDITION_TO_NAME); 
				}
			}
		}
		
		if(NLCgenericEntityFromConditionList == NULL)
		{
			//in case the moveObject was defined as "in"/"at" (condition) and not a property of the parent, eg The ball is at/in[/near] the park. Move the ball to the mountain.
			for(vector<NLCgenericEntityClass*> ::iterator iter3 = moveObjectClassList.begin(); iter3 < moveObjectClassList.end(); iter3++) 
			{
				NLCgenericEntityClass* moveObject = *iter3;
				NLCgenericEntityFromConditionList = getConditionListByConditionName(moveObject, NLC_USE_LIBRARY_MOVE_FUNCTION_ACTIONOBJECT_CONDITION_AT_NAME); 
				if(NLCgenericEntityFromConditionList == NULL)
				{
					NLCgenericEntityFromConditionList = getConditionListByConditionName(fromConditionObject, NLC_USE_LIBRARY_MOVE_FUNCTION_ACTIONOBJECT_CONDITION_IN_NAME);
				}
			}
		}
		*/

		if(NLCgenericEntityFromConditionList != NULL)
		{
			if(NLCgenericEntityToConditionList != NULL)	//this will fail with Stanford NLP until * has been implemented
			{
				for(unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*> ::iterator iter2 = NLCgenericEntityFromConditionList.begin(); iter2 != NLCgenericEntityFromConditionList.end(); iter2++)
				{
					NLCgenericEntityClass* fromConditionObject = iter2->second;
					for(vector<NLCgenericEntityClass*> ::iterator iter3 = moveObjectClassList.begin(); iter3 < moveObjectClassList.end(); iter3++) 
					{
						NLCgenericEntityClass* moveObject = *iter3;
						bool moveObjectFoundAttachedAsPropertyAndHasBeenRemoved = false;
						vector<NLCgenericEntityClass*> * fromObjectMoveObjectPropertyList = getPropertyListByName(fromConditionObject, moveObject->name); 
						if(fromObjectMoveObjectPropertyList != NULL)
						{
							if(removeItemFromVectorList(fromObjectMoveObjectPropertyList, moveObject))	//this should now work with GIA_DYNAMICALLY_LINK_FROM_CONDITIONS:linkEntitiesDynamicFromConditions
							{	
								moveObjectFoundAttachedAsPropertyAndHasBeenRemoved = true;
							}
						}

						if(moveObjectFoundAttachedAsPropertyAndHasBeenRemoved)
						{
							for(unordered_map<NLCgenericEntityClass*, NLCgenericEntityClass*> ::iterator iter4 = NLCgenericEntityToConditionList.begin(); iter4 != NLCgenericEntityToConditionList.end(); iter4++)
							{
								NLCgenericEntityClass* toConditionObject = iter4->second;
  								addPropertyListByName(toConditionObject, moveObject);
								#ifdef NLC_DEBUG_LIBRARY
								cout << "move() pass: moveParentOld (fromConditionObject) = " << fromConditionObject->name << ", moveObject = " << moveObject->name << "moveParentNew (toConditionObject) = " << toConditionObject->name << endl;
								#endif
							}
						}
						else
						{
							cout << "move() error: move object parent not found" << endl;
						}
					}
				}
			}
			else
			{
				cout << "move() error: move action 'from' condition not found" << endl;
			}
		}
		else
		{
			cout << "move() error: move action 'to' condition not found" << endl;
		}
	}
}

